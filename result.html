<section id="nice" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-xxx: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><h1 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;"><span class="prefix" style="display: none;"></span><span class="content">什么是 LLVM intrinsic</span><span class="suffix"></span></h1>
<ul><li>112313</li><li>23423</li><li>2342</li></ul>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">LLVM 支持“intrinsic function”的概念。这些函数具有众所周知的名称和语义，并且需要遵循某些限制。总的来说，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">这些 intrinsic 代表 LLVM 语言的扩展机制</code>，在添加到语言(或者位码读取器/写入器、解析器等)时不需要更改 LLVM 中的所有转换。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">Intrinsic函数是编译器内建的函数，由编译器提供，类似于内联函数。但与内联函数不同的是，因为Intrinsic函数是编译器提供，而编译器与硬件架构联系紧密，因此编译器知道如何利用硬件能力以最优的方式实现这些功能。</p>
<h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">命名格式</span><span class="suffix"></span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">intrinsic名必须全部以“ llvm”开头前缀。这个前缀在 LLVM 中保留用于intrinsic名称; 因此，函数名称不能以这个前缀开头。intrinsic函数必须始终是外部函数: 你不能定义intrinsic函数体。intrinsic函数<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">只能用于调用或调用指令</code>: 获取intrinsic函数的地址是非法的。此外，由于intrinsic函数是 LLVM 语言的一部分，如果添加了intrinsic函数，则需要对其更新文档。</p>
<h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">重载</span><span class="suffix"></span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">一些intrinsic函数可以被重载，例如，intrinsic函数表示一组在不同数据类型上执行相同操作的函数。由于 LLVM 可以表示超过800万种不同的整数类型，因此通常使用重载来允许intrinsic函数对任何整数类型进行操作。可以重载一个或多个参数类型或结果类型以接受任何整数类型。也可以将参数类型定义为与前一个参数的类型或结果类型完全匹配。这允许一个intrinsic函数接受多个参数，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">但是需要所有参数都是同一类型的，只能对一个参数或结果进行重载</code>。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">重载 intrinsic 将把它重载的参数类型的名称编码到它的函数名中，每个参数类型的前面都有一个<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">.点符号</code>。只有那些重载的类型才会生成名称后缀。其类型与另一个类型匹配的参数则不会。例如，llvm.ctpop 函数可以获取任意宽度的整数，并返回完全相同整数宽度的整数。这导致了一系列函数，如 @llvm.ctpop.i8(i8 %val)和  i29 @llvm.ctpop.i29(i29 %val).只有一个类型(返回类型)被重载，并且只需要一个类型后缀。因为参数的类型与返回类型匹配，所以它不需要自己的名称后缀。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">未命名类型被编码为 s_s。依赖于其重载参数类型中的未命名类型的重载 intrinsic 将获得一个额外的 .<number>后缀。这允许将不同的未命名类型作为参数来区分 intrinsic。(例如: llvm.ssa.copy.p0s_s.2(%42*)), 这个数字在 LLVM 模块中被跟踪，并确保模块中的唯一名称。在将两个模块链接在一起时，仍然有可能出现名称冲突。在这种情况下，其中一个名称将通过获得一个新numver来区分。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">对于为后端codegen定义 intrinsic 的目标开发人员，不应该依赖任何仅基于整数或浮点类型之间区别的内部重载来生成代码。在这种情况下，开发人员在定义 intrinsic 时， <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);">推荐的方法是创建单独的整数和 浮点的 intrinsic，而不是依赖于重载</code>。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">例如，如果 llvm.target.foo(&lt;4 x i32&gt;))和 llvm.target.foo(&lt;4 x float&gt;) 需要不同的 codegen，那么应该将它们分成不同的 intrinsic。 </p>
<h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">变量参数处理</span><span class="suffix"></span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">在 LLVM 中定义了变量参数支持，包括 va_arg 指令和三个内在函数。这些函数与 <stdarg.h> 头文件中定义的命名类似的宏相关。</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">所有这些函数都对使用特定于目标的值类型“ va_list”的参数进行操作。LLVM 汇编语言参考手册没有定义此类型是什么，因此无论使用何种类型，都应该准备好处理这些函数。</p>
<h2 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px;"><span class="prefix" style="display: none;"></span><span class="content">举个例子</span><span class="suffix"></span></h2>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">这个例子展示了如何使用 va_arg 指令和intrinsic 函数处理变量参数。</p>
<div class="codehilite" style="background-color: beige;"><pre><span></span><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: rgb(239, 112, 96);"><span class="p">;</span> <span class="err">定义一个</span><span class="n">test</span> <span class="err">函数，第一个</span><span class="n">i32是返回值</span><span class="err">，</span> 
<span class="p">;</span> <span class="err">后面括号里面的是操作数</span> <span class="n">i32</span> <span class="o">%</span><span class="n">X</span>
<span class="n">define</span> <span class="n">i32</span> <span class="err">@</span><span class="n">test</span><span class="p">(</span><span class="n">i32</span> <span class="o">%</span><span class="n">X</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="p">;</span> <span class="err">分配一个地址空间给变量，初始化</span><span class="kt">va_list</span>
  <span class="nf">%ap</span> <span class="o">=</span> <span class="n">alloca</span> <span class="nf">%struct</span><span class="p">.</span><span class="kt">va_list</span>
  <span class="nf">%ap2</span> <span class="o">=</span> <span class="n">bitcast</span> <span class="nf">%struct</span><span class="p">.</span><span class="kt">va_list</span><span class="o">*</span> <span class="nf">%ap</span> <span class="n">to</span> <span class="n">i8</span><span class="o">*</span>
  <span class="n">call</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_start</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="nf">%ap2</span><span class="p">)</span>

  <span class="p">;</span> <span class="n">va_arg</span><span class="o">=</span> <span class="n">variable_argument</span> 
  <span class="p">;</span> <span class="err">这个指令用于访问传递的参数</span>
  <span class="nf">%tmp</span> <span class="o">=</span> <span class="n">va_arg</span> <span class="n">i8</span><span class="o">*</span> <span class="nf">%ap2</span><span class="p">,</span> <span class="n">i32</span>

  <span class="p">;</span> <span class="err">演示如何使用</span> <span class="n">llvm</span><span class="p">.</span><span class="n">va_copy</span> <span class="err">和</span> <span class="n">llvm</span><span class="p">.</span><span class="n">va_end</span>
  <span class="nf">%aq</span> <span class="o">=</span> <span class="n">alloca</span> <span class="n">i8</span><span class="o">*</span>
  <span class="nf">%aq2</span> <span class="o">=</span> <span class="n">bitcast</span> <span class="n">i8</span><span class="o">**</span> <span class="nf">%aq</span> <span class="n">to</span> <span class="n">i8</span><span class="o">*</span>
  <span class="n">call</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_copy</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="nf">%aq2</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span> <span class="nf">%ap2</span><span class="p">)</span>
  <span class="n">call</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_end</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="nf">%aq2</span><span class="p">)</span>

  <span class="p">;</span> <span class="err">停止参数的处理</span>
  <span class="n">call</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_end</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span> <span class="nf">%ap2</span><span class="p">)</span>
  <span class="n">ret</span> <span class="n">i32</span> <span class="nf">%tmp</span>
<span class="p">}</span>

<span class="p">;</span> <span class="err">声明方法，类似</span><span class="n">cpp里面的extern</span> 
<span class="n">declare</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_start</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span><span class="p">)</span>
<span class="n">declare</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_copy</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span><span class="p">,</span> <span class="n">i8</span><span class="o">*</span><span class="p">)</span>
<span class="n">declare</span> <span class="kt">void</span> <span class="err">@</span><span class="n">llvm</span><span class="p">.</span><span class="n">va_end</span><span class="p">(</span><span class="n">i8</span><span class="o">*</span><span class="p">)</span>
</code></pre></div>


<h1 style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 24px;"><span class="prefix" style="display: none;"></span><span class="content">Read more</span><span class="suffix"></span></h1>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">https://zhuanlan.zhihu.com/p/53659330</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">https://docs.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170</p>
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: rgb(89,89,89);">https://llvm.org/docs/LangRef.html#intrinsic-functions</p></section>