---
layout: post
title: "从基础开始"
subtitle: '不是科班出身，所有这方面还是要下功夫'
author: "叉叉敌"
header-style: text
tags:
  - 基础
  - 计算机
---

## http和https的区别

- 概念，区别（信息是否加密涉及到安全性，端口）
- 工作原理
![1](https://gitee.com/chasays/mdPic/raw/master/uPic/m310cl.png)

![2](https://gitee.com/chasays/mdPic/raw/master/uPic/mbIsT2.png)

- https的优点和缺点
优点就是安全
缺点就是安全的太复杂了，因此加载时间增加，数据开销大，要收费，不过有免费的有时间限制。

## cookie 和session 的区别
- 前者在本地， 后者在服务器
- cookie不安全，拿到这个可以欺骗服务器。比如说爬虫
- session保存在服务器，占用服务器的性能
- 较为重要的放在session， 不重要的用cookie

## http状态码
- 有1x是消息
- 2是响应正确 200
- 3 是重定向类 如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，保持（原有）链接可用的技术。HTTP 协议提供了一种特殊形式的响应—— HTTP 重定向（HTTP redirects）来执行此类操作， 其实这种操作对用户来说是基本上没有感知的。
- 4 是错误码 一般是404 403 access denied
- 5 一般是服务器错误码，500， 503
http劫持， https可以避免这个问题，

## OSI七层协议和TCP/IP四层协议
- 应用  http
- 表示 要锁和加密数据
- 会话 开始建立链接
- 传输 tcp udp
- 网络 ip地址
- 数据链路 比如arp
- 物理  就是硬件

4层
- 应用层  http
- 传输层 tcp or udp
- IP层 ip
- 网络接口 接口1

## TCP、IP
为什么不是2次握手

- 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
- 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认
序号（sequence number）、确认号（acknowledgement number）、同步( SYNchronize )序号

为什么不是4次握手
第二次握手的时候，还发送了自己的SYN和

![wX3Fwc](https://gitee.com/chasays/mdPic/raw/master/uPic/wX3Fwc.png)

>https://blog.csdn.net/lengxiao1993/article/details/82771768





## 冒泡

```py
# bubble
def bubble(list1):
    tmpLen = len(list1)
    for i in range(tmpLen):
        for j in range(1, tmpLen - i):
            if list1[j] < list1[j-1]:
                list1[j], list1[j-1] = list1[j-1], list1[j]
                print(i, j, list1)
    return list1


# 找出字符串中第一个不重复的字符
def findFirstAlpha(s):
    tmps = []
    for i in range(len(s)):
        print(tmps)
        if s[i] not in s[:i]:
            tmps.append(s[i])
        else:
            tmps.remove(s[i])
    ret = tmps[0] if len(tmps) else None
    print(ret)
    return ret
```
![2](https://gitee.com/chasays/mdPic/raw/master/uPic/rDlc82.png)

## python 深拷贝和钱拷贝
```py
# importing copy module 
import copy 
  
# initializing list 1  
li1 = [1, 2, [3,5], 4] 
  
  
# using copy for shallow copy   
li2 = copy.copy(li1)  
  
# using deepcopy for deepcopy   
li3 = copy.deepcopy(li1)  
```
- 都开辟一个新空间
- 对于浅拷贝来说，可变不可变都是引用之前的原始
- 深拷贝来说，只有不可变才是引用之前的。
- 对于赋值来说， 就只是引用，都不开辟空间

![gqj4aD](https://gitee.com/chasays/mdPic/raw/master/uPic/gqj4aD.png)

![ewJkRx](https://gitee.com/chasays/mdPic/raw/master/uPic/ewJkRx.png)


## python 装饰器
```py
import functools
import time

def printRunTime(func):
    @functools.wraps(func)
    def wrapper(*arg, **kw):
        print(time.time())
        func(*arg, **kw)
    return wrapper

@printRunTime
def testDeco(x):
    print(x)
    return x
testDeco(11)

```
staticmethod和classmethod
- 前者是静态，调用的时候需要实例化。
- 后者是类方法， 也不需要实例化，用cls来表示当前类

## python内存管理
- 引用计数， 没有引用就不用了就回收
- 垃圾回收
- [内存池机制](https://nodefe.com/implement-of-pymalloc-from-source/)


主要是为了提高效率， 比如申请小内存后，在运行的时候在用户态和核心态之间转化，影响效率。
`不用的内存，放到内存池`，而不是返回给系统。


Python中所有小于512kb的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。`另外Python对象，如整数，浮点数和List，都有其独立的私有内存池`，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

## python
- yield 

## 测试知识



## 多线程
- 线程与进程的区别
- 线程间通信方式
GIL 全局解释锁）能确保一次执行一个线程，线程轮流保存GIL并且在把他传给下一个线程之前执行一些操作，以达到多个进程在CPU上轮流运行，但是这个转换速度很快，让我们觉得他是并行的。

- 实现多线程的方式
- 这个需要用代码来实现


## 服务器出问题了，怎么排查
考察的是服务器错误码的分析。
- 500 internal server error就是程序内部错误，一般是出现空指针，或者数组访问越界等
- 501 not implemented这个就是 服务器不支持这个请求
- 502 bad gateway 网关错误，这个就有很多问题了， 有网络问题、请求人太多、带宽太小，服务器交互太大，优化协议
- 503 service unavailable  这个一般是暂时的，比如超载等
- 504 gateway timeout 这个就是比如服务器这个请求需要40s， 但是其他类似nginx的配置是30s超时，这个时候就会提示504

遇到问题怎么去解决
- 查看错误码
- 查看对应的log 或者 带宽和服务器负载问题
- 然后修复对于的问题，然后看看问题时候重现


## 内存溢出和内存泄漏
测试内存可以考虑的2个点，以及原理是什么。
溢出就是超出了， 申请的空间超出了。 空间不足
泄露，就是信息泄露给别人了，就是临时变量没有回收。使用空间过多，导致没有空间可以用。
- 对于android 可以用dumpsys meminfo packagename 来查看对于的views和activity
- 使用第三方工具来分析内存泄漏。比如LeakCanary

>内存溢出：简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。

内存泄漏：内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；

内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。

memory leak会最终会导致out of memory！

内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。


## linux里source、sh、bash、./有什么区别
考察对Linux的熟悉程度。
这里可以看一下GNU是什么。
source sh bash都是执行文件，后2个是在一个subshell里面执行的， 都不需要被执行文件有执行权限。
./就是需要文件有权限。
- source 不会建立一个subshell， 因此设置后的环境变量就会当前生效。用处就是设置环境变量，或者执行一个文件，里面有一些命令
- sh和bash都是在一个subshell里面执行，这个shell继承了父类的环境变量，但是执行完了后不会待会到父类。不影响父类，可以用于有些脚本的执行等。


## 7升水和11升水怎么倒出2升
以任一一个为参照物， 另一个为获得差值。然后把差值放入到参照物。然后差值继续转。。。

## SQL

sql语句，简单的，显示姓“王”和按年龄倒序输出
```sql
select * from user where firstName='王' order by age desc;

## and
SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'

## like 
SELECT * FROM Persons WHERE City LIKE 'N%';

# 顺序很重要
FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT;
SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5
FROM player JOIN team ON player.team_id = team.team_id # 顺序 1
WHERE height > 1.80 # 顺序 2
GROUP BY player.team_id # 顺序 3
HAVING num > 2 # 顺序 4
ORDER BY num DESC # 顺序 6
LIMIT 2 # 顺序 7
```

## user age > 5 10 hubs 逆序

select * from user where age > 5 having sum(hub_number)>10 order by desc;