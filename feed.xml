<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>察说花园</title>
    <description>人生就是干</description>
    <link>https://blog.chiphub.top/</link>
    <atom:link href="https://blog.chiphub.top/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 07 Apr 2023 13:54:07 +0000</pubDate>
    <lastBuildDate>Fri, 07 Apr 2023 13:54:07 +0000</lastBuildDate>
    <generator>Jekyll v3.9.3</generator>
    
      <item>
        <title>哈夫曼编码</title>
        <description>&lt;p&gt;哈夫曼编码是一种在无损信息的情况下压缩数据的有效方法。在计算机科学中，信息被编码为比特：1和0。位串编码的信息告诉计算机要执行哪些指令。视频游戏、照片、电影等等在计算机中被编码为比特串。计算机每秒执行数十亿条指令，而一个视频游戏可能是数十亿比特的数据。不难看出，为什么高效和不含糊的信息编码是计算机科学中一个令人感兴趣的话题。&lt;/p&gt;

&lt;p&gt;哈夫曼编码通过分析某些符号在信息中出现的频率，提供了一种高效、明确的编码。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;出现频率较高的符号将被编码为较短的比特串，而使用频率不高的符号将被编码为较长的字符串&lt;/code&gt;。然后用这种频率的编码来&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;替换原来的信息，出现频率较高的就会替换为较短的编码，从而节省空间。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406085143.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面图中对字符串&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABCD&lt;/code&gt;构建一个huffman的二叉树，如果要对CBA编码，结果就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;011011&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;由于符号的频率在不同的信息中是不同的，所以没有一种哈夫曼编码可以适用于所有的信息。这意味着，发送消息X的哈夫曼编码可能与发送消息Y的哈夫曼编码不同。&lt;/p&gt;

&lt;h2 id=&quot;huffman的原理&quot;&gt;huffman的原理&lt;/h2&gt;

&lt;p&gt;对于哈夫曼编码的原理，我是看了这个教程就了解了，我直接搬运过来，借鉴下大佬的讲解。重点的地方，我自己第一次没有太理解的地方，我加了部分补充来理解。&lt;/p&gt;

&lt;p&gt;下面是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;we will we will r u&lt;/code&gt;中每个字符出现的频率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092329.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;构建二叉树&quot;&gt;构建二叉树&lt;/h2&gt;

&lt;p&gt;对于上面这样的值，构建一个二叉树来表达每一个字符的路径信息。&lt;/p&gt;

&lt;h3 id=&quot;初始队列&quot;&gt;初始队列&lt;/h3&gt;
&lt;p&gt;那么我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092623.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面我们需要将这个队列转换成哈夫曼二叉树，哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的。并且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;哈夫曼二叉树始终保证权重越大的字符出现在越高的地方&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;这样就是出现频率越高的字符，编码的路径就越短，这样编码出来的结果就越少。&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;第一步合并&quot;&gt;第一步合并&lt;/h3&gt;
&lt;p&gt;首先我们从左到右进行合并，依次构建二叉树。第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092634.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同理，新元素可以和字符i再合并，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092649.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;重新调整队列&quot;&gt;重新调整队列&lt;/h3&gt;
&lt;p&gt;上图新元素权重相加后结果是变大了，需要对权重进行重新排序。
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092814.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后再依次从左到右合并，每合并一次则进行一次队列重新排序调整。如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092827.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：&lt;/p&gt;

&lt;p&gt;重点就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;当根节点的权重大于剩余权重的时候，就要新开一个节点，下图中的I、W，权重都是4，而当前根节点的权重为11，所以就新开了一个节点。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092845.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;哈夫曼编码&quot;&gt;哈夫曼编码&lt;/h3&gt;
&lt;p&gt;有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092907.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。
最终我们可以得到下面这张编码表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230406092928.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;show-me-the-code&quot;&gt;show me the code&lt;/h2&gt;

&lt;p&gt;huffman的具体实现步骤：
1）将信源符号的概率按减小的顺序排队。
2）把两个最小的概率相加，并继续这一步骤，始终将较高的概率分支放在右边，直到最后变成概率１。
3）画出由概率１处到每个信源符号的路径，顺序记下沿路径的０和１，所得就是该符号的霍夫曼码字。
4）将每对组合的左边一个指定为0，右边一个指定为1（或相反）。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 这是一个关于Huffman编码的测试用例&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Huffman树节点&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 比较函数，用于优先队列&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 构建Huffman树&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;buildHuffmanTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;priority_queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'$'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 递归函数，用于生成Huffman编码&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateHuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'$'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;generateHuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;generateHuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 打印Huffman编码&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printHuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decltype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buildHuffmanTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;generateHuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printHuffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出的结果：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 打印的huffman编码结果&lt;/span&gt;
w 1111
h 001
o 01
e 000
l 10
r 1100
  1110
d 1101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对应的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello world&lt;/code&gt;的编码就是如下&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// iterate over each character in the string&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// std::cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; std::endl; // print the character&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;huffmanCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 00100010100111101111011100101101&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后的长度就是32位，如果用原始的编码是实现，就是11*8=88位才能存下，空间减少63%，可见这个效果是多么的好。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/FX677588/article/details/70767446&quot;&gt;详细图解哈夫曼Huffman编码树&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Young_IT/article/details/106730343&quot;&gt;哈夫曼编码详解——图解真能看了秒懂&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/04/06/huffman-coding/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/04/06/huffman-coding/</guid>
        
        <category>algorithm</category>
        
        <category>huffman</category>
        
        
      </item>
    
      <item>
        <title>83 -  保持好奇</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230331084307.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AIGC现在可谓是大红大紫，尤其是chatgpt4和midjourney，你怎么看待它们呢？&lt;/p&gt;

&lt;p&gt;我自己的心态经历了从期待到焦虑，再到憧憬的过程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先，让自己来谈谈我对这些技术工具的第一印象。当它们第一次出现时，我以为它们只是普通的技术工具，没有太多特别之处，所以我对它们并没有太多期待。但是，随着我慢慢地接触和使用它们，我发现它们真的非常强大，可以帮助自己解决很多问题，让自己的工作变得更加高效和便捷。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其次，我对这些技术工具保持着好奇心。我相信，只有保持好奇心，才能不断地探索新的可能性，发现新的功能和特性。因此，我会尽量关注一些一线的开发者，听取他们的声音，了解最新的技术趋势和发展动态。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，对于未来，自己应该有什么打算呢？我认为，自己需要做以下几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;要对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一线的信息保持好奇心&lt;/code&gt;，不要只看二手的信息，而是尽量关注一些一线的开发者，听取他们的声音。这样，自己才能了解最新的技术趋势和发展动态，及时掌握最新的技术动态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不要被标题党所迷惑&lt;/code&gt;，那些所谓的“xx用这个技术赚了几百万”之类的垃圾文，可能会引发自己的焦虑，自己应该保持冷静，不要被这些无意义的信息所干扰。自己应该专注于自己的工作，不断提高自己的技能和能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果自己有好的想法或者发现有好的需求，就要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;动手去实践，保持知行合一&lt;/code&gt;，这样才能不断提高自己的技能和能力。自己应该不断地尝试新的技术和工具，探索新的可能性，为未来的发展打下坚实的基础。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;让自己一起保持好奇心，不断探索新的技术和工具，为未来的发展打下坚实的基础！&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/j5xPMjrwTLconbUS4MTc9A&quot;&gt;深度剖析：ChatGPT 及其继任者会成为通用人工智能吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/G4uaBE.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ChatGPT是一种大语言模型，其目标是总结人类语言使用的统计规律。它通过互联网等来源提供的语言材料训练一个巨型人工神经元网络，直接在字词、语句等水平上总结语言使用者的习惯。在预训练的基础上，ChatGPT又经过了一个强化学习过程，在其中人类训练者为它提供了大量典型问题，并对其回复进行奖励或惩罚，通过调整模型的参数使得其行为符合人类要求。ChatGPT的内容广度和语言流畅性是因为它所说的话就是该语言的使用者们在相同的语境下最可能说的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;[人工智能时代已经开始&lt;/td&gt;
          &lt;td&gt;盖茨笔记](https://mp.weixin.qq.com/s/pYjY_LT8I33YqCn415AUAA)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;人工智能（AI）和通用人工智能（AGI）的发展一直是计算行业的伟大梦想。现在，随着机器学习和大量计算能力的出现，复杂的人工智能已经成为现实，而且它们会快速迭代升级。人工智能将改变人们工作、学习、旅行、获得医疗保健以及彼此交流的方式。整个行业将围绕人工智能重新洗牌。企业也将根据其利用人工智能技术的程度来区分优劣。人工智能可以减少世界上一些最严重的不平等现象，如改善教育、拯救生命、减少气候变化等。政府和慈善机构将需要发挥重要作用，以确保人工智能是在减少而非加剧不平等现象。这是我自己人工智能相关工作的重点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jSH0WTGrABZg4jRA9g21YA&quot;&gt;网课后，农村留守儿童正在塌陷式沉迷手机&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这篇文章主要讲述了农村留守儿童沉迷手机的现象。文章从2017年开始关注到这个问题，到2021年的调研发现，这个问题已经变得更加严重。文章提到，40.4%的留守儿童有专属手机，49.3%的留守儿童使用长辈的手机。其中21.3%的家长认为孩子严重沉迷手机，事态已十分严重。文章还提到了一些案例，比如小孩玩游戏相约自杀，11岁的女孩在游戏中认识某外地17岁的男孩，确定恋爱关系后相约在宾馆发生关系等。文章认为，孩子们沉迷手机的原因有很多，比如手机内容的丰富度和吸引力，网络游戏、短视频往往使用了增强黏性的算法设计等。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://app.copilothub.co/chat?id=5&quot;&gt;copilothub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我试了下，类似github copilot，还是不错的，每个用户有10次免费的配额。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://orbstack.dev/&quot;&gt;orbstack容器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在你的Mac上无缝、高效地运行Docker和Linux。通过直观的集成来简化你的开发工作流程。&lt;/p&gt;

&lt;p&gt;OrbStack在测试期间是完全免费使用的，但之后它将成为一个付费产品。仍在制定细节（个人与企业使用，订阅与永久许可，定价，开放源码和学生折扣，等等），并将在接近推出时分享更多信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/vincelwt/chatgpt-mac&quot;&gt;chatgpt-mac&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mac版ChatGPT，支持 intel 和 m 系列芯片。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/apple/ml-ane-transformers&quot;&gt;apple ane-transformers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果您考虑在搭载A14或更新版本和M1或更新版本芯片的Apple设备上部署Transformer模型，并希望相对于基准实现实现高达10倍更快和14倍更低峰值内存消耗，请使用ane_transformers作为PyTorch参考实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/TiesdeKok/chat-gpt-jupyter-extension&quot;&gt;chat-gpt-jupyter-extension&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个浏览器扩展，在Jupyter笔记本中提供各种人工智能辅助功能，由ChatGPT提供。&lt;/p&gt;
</description>
        <pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/04/01/Stay-curious/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/04/01/Stay-curious/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>如何调试我们 LLVM 的代码 - 进阶</title>
        <description>&lt;p&gt;前面简单介绍了如何从一个bc文件里面提炼出一个精简的ll文件，只包含报错的函数。&lt;/p&gt;

&lt;p&gt;如果看到的不正确的行为是由于一个优化pass，一个非常方便的LLVM选项是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-opt-bisect-limit&lt;/code&gt;，它采用一个整数表示要运行的最高pass的索引值。所取pass的索引值在不同的运行中是稳定的；通过将其与根据结果程序自动划分搜索空间的软件相结合，可以快速确定错误的通道。当指定了-opt-bisect-limit时，所有的运行都会被显示到标准错误中，同时显示它们的索引和输出，表明是否运行或跳过了该通道。将限制设置为索引-1（例如，RUSTFLAGS=”-C llvm-args=-opt-bisect-limit=-1”）将显示所有的通过和它们相应的索引值。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/30/how-to-debug-llvm-code-2/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/30/how-to-debug-llvm-code-2/</guid>
        
        <category>compiler</category>
        
        <category>LLVM</category>
        
        <category>debug</category>
        
        
      </item>
    
      <item>
        <title>82 -  知行合一</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多听听播客、多出去走走，旅游，会带给你不同领域的知识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「生财有术」一个谈钱不伤感情的社群，目前的 418 会员日来了，我有2点建议。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;利用信息差赚钱，等到大众知道这个消息的时候，这个行业就是红海， 不是蓝海了，就很少有机会来赚钱了&lt;/li&gt;
  &lt;li&gt;执行力，这个是钞能力路上不可获取的一个能力；也是大部分人缺少这个能力的。如果你的执行力不强，我还是劝退你，毕竟现在的肉价才20+，接近2000的会员费。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你和我一样，不是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;知行合一&lt;/code&gt;的人，我个人建议你没必要加入，毕竟年会费接近2000，菜场100块都可以买好多菜喃。&lt;/p&gt;

&lt;h2 id=&quot;站在对方的角度思考&quot;&gt;站在对方的角度思考&lt;/h2&gt;

&lt;p&gt;打羽毛球，你想接什么球？高远球，不急不快的，不重的，让你有时间调整步伐和姿势。&lt;/p&gt;

&lt;p&gt;那反过来你不想接什么球？低平球，快速的，重的，让你难以抵挡和还击。对方也不想接这样的球，所以你要尽量发出这样的球，给对方制造压力和困难。&lt;/p&gt;

&lt;p&gt;对于竞技类、对抗类游戏，比如电子游戏、篮球、拳击，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;做对方害怕或者是不想做的事情&lt;/code&gt;，结果不会太差。&lt;/p&gt;

&lt;h2 id=&quot;玩德州扑克&quot;&gt;玩德州扑克&lt;/h2&gt;

&lt;p&gt;我估计不少人应该玩过扑克里面的「炸金花」。&lt;/p&gt;

&lt;p&gt;最近我开始玩上了德州扑克，可比四川炸金花更有趣，不仅是一种全球性的扑克游戏，还荟萃了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;金融、概率、心理博弈等多方面的元素&lt;/code&gt;，每年的大大小小比赛。&lt;/p&gt;

&lt;p&gt;最近我在德州扑克里面，体验了 2 种乐趣：平衡感和过程体验。&lt;/p&gt;

&lt;p&gt;保持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;平衡感是德州扑克&lt;/code&gt;中非常重要的一点，它不论是什么牌都需要保持平衡，不然很容易被对手发现缺陷，甚至会被对手构成炸弹局面。只有保持平衡感，玩家才能在游戏中更好的进行策略性的思考和判断，炸金花也有类似的体验。&lt;/p&gt;

&lt;p&gt;但是又与炸金花不同，德州扑克不是一个单纯为了奖金而存在的游戏，玩家更是享受其中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;过程体验&lt;/code&gt;。在游戏中每一个过程都需要刻意&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;选择纪律性，掌握机会与风险&lt;/code&gt;，才能在整场比赛中获得胜利。这种过程体验能够带给玩家非常深刻的提升，让他们在游戏中享受每个过程带来的乐趣和收获。&lt;/p&gt;

&lt;p&gt;相对于彩票中奖的概率较低，德州扑克显然存在着较高的ev和获胜概率。到达游戏中的每一个环节，玩家们的技巧和运气会影响其获胜概率和收益，只有做好准备和规划，才能收获出色的结果。因此，德州扑克是一种非常刺激的游戏，让玩家们敢于追求胜利与乐趣并存的感觉。&lt;/p&gt;

&lt;p&gt;说到正ev，那就有负ev。比如彩票中奖概率很低，最后一等奖只有奖池的70%，这个就是很明显的负ev。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么是负 expect value？ 是指一个行动或策略在长期下来会带来的平均损失。它是所有可能的结果乘以其结果概率的总和的负数。例如，如果你掷一枚公平的六面筛子，每次掷出的点数就是你赢得的钱数，但是每次掷之前你要付出4元，那么你的 expect value 是：&lt;/p&gt;

  &lt;p&gt;(1/6)×1 + (1/6)×2 + (1/6)×3 + (1/6)×4 + (1/6)×5 + (1/6)×6 - 4 = -0.5&lt;/p&gt;

  &lt;p&gt;这意味着你每次玩这个游戏，平均会亏损0.5元，所以这是一个负 expect value 的游戏。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/AW_z1fVecX1Mq7PGBoLiyQ&quot;&gt;瑞信，死不足惜&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;强买强卖的说法并不夸张，因为瑞信在纽约和苏黎世两地上市，瑞信的股东们对这次收购应该有投票权的，但瑞士政府单方面耍横——必须卖&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iFtlqgDrtknfAq7iNQpzAw&quot;&gt;AI art 实验：同样的Prompt, DALLE2 跟 Disco Diffusion 的创作大比拼&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者对比2种图片生成模型的结果，已经不同情况下，那种更好一点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fatsoftwareengineer.substack.com/p/building-a-second-income-stream-by&quot;&gt;通过写书建立第二收入来源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230323085914.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作者分享了他如何通过写一本技术书籍来建立一个第二收入流的经历。他讲述了以下几个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;他是如何被一家知名的技术书籍出版商联系的，以及他为什么同意接受这个挑战。&lt;/li&gt;
  &lt;li&gt;写一本书的过程是怎样的，包括写作计划、编辑反馈、合同条款、版权问题等。&lt;/li&gt;
  &lt;li&gt;他目前从书籍中赚了多少钱，以及他对未来的收入预期是什么。&lt;/li&gt;
  &lt;li&gt;他是否会再次写书，以及他对想要写书的人的一些建议。&lt;/li&gt;
  &lt;li&gt;作者认为写一本书是一种非常困难和耗时的方式来建立一个被动收入流，但也是一种有价值和有成就感的方式。他强 - 调了保持质量和专业性的重要性，以及在写作过程中保持动力和耐心的必要性&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/paulocoutinhox/pdfium-lib&quot;&gt;pdfium-lib&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://xiaobot.net/p/shengcaiyoushu?&quot;&gt;生财有术项目精选&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个付费的类容，如果你是一个知行合一，搞钱特别行，那可以看看里面的赚钱路子。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://streamlit.io/&quot;&gt;Streamlight&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过应用程序构建和共享数据的更快方式
Streamlight 在几分钟内就能将数据脚本变成可共享的网络应用程序。
所有这些都是在一个纯Python中实现的，不需要任何前端经验。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/m8hiQo6smRnHFjPkGfYLNQ&quot;&gt;关于GPT答朋友问&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在另外一边，AI也好，GPT也罢，未来算力提升会让智能提升到什么人类无法想象和企及的境界我不清楚，起码在现在，它们没可能超脱于现实世界而独立存在。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://codeium.com/&quot;&gt;codeium 类似github copilot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;codeium 类似github copilot，支持各种IDE的插件，对于个人用户来说，目前是永久免费。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/antimatter15/alpaca.cpp&quot;&gt;alpaca.cpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在你的设备上本地运行类似于ChatGPT的快速模型。意思就是可以在普通的笔记本上运行这个模型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.duolingo.com/duolingo-max/&quot;&gt;duolingo-max&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Duolingo 推出了新的订阅层次 Duolingo Max，提供两项新的基于人工智能技术的功能：Explain My Answer 和 Roleplay。这些功能可以让学习者了解自己的答案并练习与 AI 生成的角色进行真实对话。Duolingo 与 OpenAI 密切合作数月来完善技术，并确保准确性。人类评估内容并审查由 AI 生成的解释以确保事实正确和适当的语气。这些新功能仅在 iOS 上的面向英语使用者的西班牙语和法语课程上可用，在部分国家上线，计划很快扩展。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/25/Forward-Position/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/25/Forward-Position/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>如何调试我们 LLVM 的代码 - 入门</title>
        <description>&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;

&lt;p&gt;LLVM是一个独立的大项目，可能需要有自己的调试文档，我似乎没有找到这样的文档，估计做LLVM都是的大佬或者是骨灰级的人物，不需要文档吧，注释就在代码中。&lt;/p&gt;

&lt;p&gt;比如在开发一个llvm的pass，或者一个feature，在编译的过程中crash了， 怎么去定位和修复的喃？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230317094622.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意官方编译器禁用了LLVM断言，这意味着LLVM断言失败可能会显示为编译器崩溃（不是ICE-内部编译错误，而是 “真正的”崩溃）和其他各种奇怪的行为。编译llvm的时候最好使能assertion，在cmake的时候记得带上参数即可：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertions=true&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;尽量最小化例子&quot;&gt;尽量最小化例子&lt;/h2&gt;

&lt;p&gt;一般来说，编译器从分析代码中产生大量的信息。因此，一个有用的第一步通常是找到一个最小的例子。做到这一点的一个方法是&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个重现该问题的新case（例如，将有问题的地方添加为依赖关系，并从这里开始）&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;移除外部依赖关系&lt;/code&gt;来最小化这个板块；也就是说，将所有相关的东西移到新文件中去&lt;/li&gt;
  &lt;li&gt;通过缩短代码来进一步减少问题（有一些工具可以帮助实现这一点，比如creduce）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际的工程中，是通过如下步骤，不过工程有一点差异，但是可以参考这个过程：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用编译器（gcc/clang,或者其他）编译cpp文件为一个ll文件&lt;/li&gt;
  &lt;li&gt;通过上面生成的 ll 文件，从中提取报错函数的最小 ll文件&lt;/li&gt;
  &lt;li&gt;然后带上mtriple，map，mcpu等参数用llc来编译这个 ll 文件为汇编，一般在这个时候就会出问题了。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 编译cpp为一个ll文件&lt;/span&gt;
clang &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-emit-llvm&lt;/span&gt; test.cpp

&lt;span class=&quot;c&quot;&gt;# 提取文件里面的该funtion有关的ir&lt;/span&gt;
llvm-ir-extractor test.ll &lt;span class=&quot;nt&quot;&gt;--save-mode&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;functioName&quot;&lt;/span&gt; &amp;amp;&amp;gt; new.ll

&lt;span class=&quot;c&quot;&gt;# 用llc来编译&lt;/span&gt;
llc &lt;span class=&quot;nt&quot;&gt;-mtriple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;amdgpucn &lt;span class=&quot;nt&quot;&gt;-verify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;machineinstrs new.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;获得一个原始的输入文件&quot;&gt;获得一个原始的输入文件&lt;/h2&gt;

&lt;p&gt;大致情况是把一个crash文件，一个bc文件转化为一个ll文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果在调用LLVM时遇到了来自 LLVM 后台的断言失败或分段故障，不妨尝试将这些 .bc 文件分别传递给 llc 命令，看看是否得到了同样的失败。(LLVM的开发者通常更喜欢被简化为.bc文件的bug，而不是使用工具最小化再来复现)。&lt;/li&gt;
  &lt;li&gt;为了得到人类可读的LLVM bc文件，人们只需要使用llvm-dis将位码（.bc）文件转换为.ll文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果只想在LLVM pipeline中获得LLVM的IR，例如查看哪个IR导致优化时间断言失败，或者查看LLVM何时执行特定的优化，可以通过llvm标志位&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-print-after-all&lt;/code&gt;，这样就可以获得更多的报错信息，从而精准找到问题所在。&lt;/p&gt;

&lt;p&gt;这将产生大量的输出到标准错误中，所以要把这些输出管到某个文件中。另外，如果既没有使用-filter-print-funcs，也没有使用-C codegen-units=1，那么，由于多个codegen单元并行运行，打印结果会混在一起，会有很多的无效信息，将无法阅读任何东西，或者很难找到问题所在。&lt;/p&gt;

&lt;p&gt;如果是单个函数在一个ll文件或者是bc文件里面，这样用这个方法是好处理，但是有多个函数，估计就不好处理了，还可以继续精简么？&lt;/p&gt;

&lt;p&gt;精简到只有这个对应函数和其依赖，这样就好定位处理了，同时也能把这个case加入到日常的看护中。&lt;/p&gt;

&lt;p&gt;可以用到2个工具，一个是llvm-extract/llvm-ir-extractor。&lt;/p&gt;

&lt;p&gt;先说说第一个的用法，还是举个例子吧。&lt;/p&gt;

&lt;p&gt;准备一个ir文件，在x86的机器上运行，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ll&quot;&gt;declare {i32, i1} @llvm.sadd.with.overflow.i32(i32, i32)
declare {i32, i1} @llvm.uadd.with.overflow.i32(i32, i32)

; The immediate can be encoded in a smaller way if the
; instruction is a sub instead of an add.
define i32 @test1(i32 inreg %a) nounwind {
entry:
  %b = add i32 %a, 128
  ret i32 %b
}

define i32 @test1b(i32* %p) nounwind {
entry:
  %a = load i32, i32* %p
  %b = add i32 %a, 128
  ret i32 %b
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个ir文件里面，包含了2个函数，分别为test1和test1b，现在需要把test1函数提出来，只需要这个函数。的ll文件。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llvm-extract &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'test_add'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &amp;lt; add.ll &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; extracted.ll

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行上面命令后，查看 extracted.ll，这个文件里面的内容如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ll&quot;&gt;; ModuleID = '&amp;lt;stdin&amp;gt;'
source_filename = &quot;&amp;lt;stdin&amp;gt;&quot;

; Function Attrs: nounwind
define i32 @test1(i32 inreg %a) #0 {
entry:
  %b = add i32 %a, 128
  ret i32 %b
}

attributes #0 = { nounwind }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是简单了。今天就先来一个简单的，后面继续学习下一个关于优化pass的调试和定位。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/backend/debugging.html#enable-llvm-internal-checks&quot;&gt;Rust Compiler Development Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/&quot;&gt;rust 最小化代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/18/how-to-debug-llvm-code/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/18/how-to-debug-llvm-code/</guid>
        
        <category>compiler</category>
        
        <category>LLVM</category>
        
        <category>debug</category>
        
        
      </item>
    
      <item>
        <title>81 -  GPT4 来了</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;如果有一天你发现自己被一台电脑取代了怎么办？别担心，这不是科幻小说里的情节，而是可能很快就会发生在我们身边的现实。因为 GPT4 已经出现了！&lt;/p&gt;

&lt;p&gt;GPT4  是什么？简单地说，它就是一个能写出任何东西的超级机器人。不管你想要什么样子、什么风格、什么内容、什么语言、什么格式、什么长度、甚至什么字体都可以满足你。&lt;/p&gt;

&lt;p&gt;听起来很神奇吧？但是也很可怕！因为它不光能写出东西，还能写得比我们更好！&lt;/p&gt;

&lt;p&gt;GPT4 的出现，让许多人感到焦虑不安，其中最重要的两个问题是：是否能赚到钱和是否会被取代或失业。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230317085036.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于第一个问题，历史规律表明，只有少部分人能够从这种类型的技术中赚到钱。此类人主要是利用信息差贩卖信息的，他们可能会从中获得可观的收入。现在像知识星球和小报童这些已经开始推出各种课程，每天都有很多人报名，并且在短时间内得到了非常好的回报。&lt;/p&gt;

&lt;p&gt;虽然对于我们这些普通人而言，赚钱的机会可能较少，但可以通过学习一些 prompt 和提示词，并将其应用于日常生活中，例如当我作为一个程序员遇到困难时，通常我更倾向于在网上使用 Google 或 Stack   Overflow 查询。这些答案有可能很难找到，但你可以快速地将你的问题描述给 ChatGPT ，并很快地找到解决办法，我身边有很多人遇到问题都喜欢通过询问 ChatGPT 来解决，这种方法比自己去找答案更快更省时。&lt;/p&gt;

&lt;p&gt;对于第二个问题，我们可以考虑到一些容易被替代的工作，例如文字编辑和 PPT 的简单制作等没有技术门槛的工作，在 ChatGPT   Plus 的 API 接口上，每个月只需花费 200 块，就能找到一个替代人员，难道你会雇一个人只给他/她 100 块吗？这是不现实的，因此这些替代工作可能会被取代。&lt;/p&gt;

&lt;p&gt;目前已经有些公司开始使用 Midjourney   v5 来生成一些图像，例如制作定制化的图片等，这是一项非常有新意的技术，能够生成非常逼真的图像，甚至超越人类能力，完全看不出是由 AI 生成的。&lt;/p&gt;

&lt;p&gt;但是，这些技术是否会为我们带来收益还存在一定的疑虑，例如生成一首歌曲，但如果这首歌曲并没有广受欢迎或者没有被商用，则可能只是娱乐而已，无法为我们带来实际的价值。因此，我们应该是以结果为导向，将这些技术应用于实际领域中，使之与商业结合起来，这样才能发挥其真正的潜力，而不仅仅停留在娱乐的层面上。&lt;/p&gt;

&lt;p&gt;总的来说， GPT4 的出现无疑为我们带来了很多便利和创造机会，但我们也应该意识到，如何将这些技术应用于实际问题上，创造出更多有价值的产品和服务，才是这项技术发展的关键所在。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份 Newsletter ，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wallstreetcn.com/articles/3684246&quot;&gt;微软深夜放炸弹！GPT-4 Office全家桶发布，10亿打工人被革命&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;微软宣布Microsoft 365 Copilot，将在未来几个月内把OpenAI的GPT-4带到Excel、PowerPoint、Outlook、Word及其他Office应用中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.bloomberg.com/news/articles/2023-03-16/chip-globalization-is-over-and-sanctions-work-says-tsmc-founder&quot;&gt;台积电创始人说：芯片全球化已经结束，制裁起作用了&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://yesaiwen.com/art-of-asking-chatgpt-for-high-quality-answ-engineering-techniques/?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=61310502961152&quot;&gt;如何向ChatGPT提问并获得高质量的答案&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非常高兴您阅读我的新书《如何向ChatGPT提问并获得高质量的答案——提示技术的完整指南》。&lt;/p&gt;

&lt;p&gt;本书是一本综合性的指南，目的是帮助您理解和利用各种提示技术，以便从ChatGPT中获得高质量的答案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.bing.com/search/march_2023/Confirmed-the-new-Bing-runs-on-OpenAI%E2%80%99s-GPT-4&quot;&gt;证实：新必应在OpenAI的GPT-4上运行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过需要全程科学上网。&lt;/p&gt;

&lt;p&gt;新的Bing是在GPT-4上运行的，MS 为搜索进行了定制。如果你在过去五周的任何时候使用过新必应预览版，你已经体验到了这个强大模型的早期版本。随着OpenAI对GPT-4及以后的更新，Bing将从这些改进中受益。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.org/blog/pytorch-2.0-release/&quot;&gt;pytroch 2.0 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PyTorch 2.0提供了相同的急切模式开发和用户体验，同时从根本上改变和提高了PyTorch在编译器层面的运行方式，提高了性能并支持动态形状和分布式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/m8hiQo6smRnHFjPkGfYLNQ&quot;&gt;关于GPT答朋友问&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在另外一边，AI也好，GPT也罢，未来算力提升会让智能提升到什么人类无法想象和企及的境界我不清楚，起码在现在，它们没可能超脱于现实世界而独立存在。&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/18/GPT4-release/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/18/GPT4-release/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>如何通过chatgpt，获取高质量的回答</title>
        <description>&lt;h1 id=&quot;开篇&quot;&gt;开篇&lt;/h1&gt;

&lt;p&gt;任务：对模型生成内容的清晰、简洁的陈述。&lt;/p&gt;

&lt;p&gt;说明：模型生成文本时应遵循的指令。&lt;/p&gt;

&lt;p&gt;角色：模型在生成文本时应承担的角色。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yesaiwen.com/art-of-asking-chatgpt-for-high-quality-answ-engineering-techniques/?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=61310502961152&quot;&gt;《如何向ChatGPT提问并获得高质量的答案》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/17/chatgpt-promt-words/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/17/chatgpt-promt-words/</guid>
        
        <category>chatgpt</category>
        
        <category>promt</category>
        
        
      </item>
    
      <item>
        <title>编译器优化 3 - 常量折叠和传播</title>
        <description>&lt;p&gt;前面了解了lto、thinlto、以及inline优化、死代码优化等。今天继续学习下常量折叠优化，&lt;/p&gt;

&lt;h2 id=&quot;常量折叠和常量传播&quot;&gt;常量折叠和常量传播&lt;/h2&gt;

&lt;p&gt;常量折叠和常量传播有什么不同？它们似乎都做了同样的事情，而不是将常量保存到堆栈中或计算完整的算术表达式，而是简单地将其替换为可以在编译时获得的结果。两者之间有什么不同？&lt;/p&gt;

&lt;p&gt;区别在于，常量传播&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不是将一个变量保存到堆栈中&lt;/code&gt;，因为我们知道它是一个常量，可以简单地将它插入到任何地方，它被用于机器代码中。而常数折叠是简单地评估，使用常数的表达式，并将结果代入机器码。&lt;/p&gt;

&lt;p&gt;来吧，看一个例子&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 常量传播&lt;/span&gt;
x &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 10
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x + x + x
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 10 + 10 + 10

&lt;span class=&quot;c&quot;&gt;# 常量折叠&lt;/span&gt;
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 10 + 10 + 10
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这就是区别。常量传播只是用绑定的常量表达式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;替换绑定的变量&lt;/code&gt;，而常量折叠则&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;是评估一个（无副作用的）表达式&lt;/code&gt;，其中所有输入都是编译时常量。&lt;/p&gt;

&lt;p&gt;常量传播是一种编译器优化方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;，它可以在编译期间用常量值替换变量或表达式，从而减少运行时的计算开销和代码大小&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;常量传播有四种算法：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;简单常量传播、稀疏简单常量传播、条件常量传播和稀疏条件常量传播&lt;/code&gt;，它们的效率和精度各有不同。&lt;/p&gt;

&lt;p&gt;常量折叠是一种与常量传播相关的优化方法，它可以将具有已知常量值的运算符表达式简化为操作数。&lt;/p&gt;

&lt;h2 id=&quot;常量折叠&quot;&gt;常量折叠&lt;/h2&gt;

&lt;p&gt;常量折叠是指在编译时识别和评估常量表达式的过程，而不是在运行时计算它们。常量表达式中的术语通常是简单的字面意义，例如整数字面意义2，但它们也可能是变量，其值在编译时已经知道。考虑一下这个语句。&lt;/p&gt;

&lt;p&gt;比如： i = 20* 20 * 10;&lt;/p&gt;

&lt;p&gt;上面这个表达式，有2个乘号，很少有编译器的指令会对2个乘号做运算，并存到一个寄存器，比如我下才一个：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mul_mul dst,src0,src1,src2&lt;/code&gt;,想这样的指令看起来就比较怪异。所以在编译的时候替换计算值为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;常量折叠可以利用算术特性。如果x是数字，即使编译器不知道x的值，0*x的值也是零。&lt;/p&gt;

&lt;p&gt;注意，大部分编译器对 IEEE754 浮点数是无效的，因为x可能是Infinity或NaN。不过，为了性能，某些编译器允许对常数这样做。&lt;/p&gt;

&lt;p&gt;常数折叠可能不仅仅适用于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;数字。字符串和常量字符串&lt;/code&gt;的拼接可以被常量折叠。像 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;abc&quot;+&quot;def&quot;&lt;/code&gt;这样的代码可以被替换为 “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abcdef&lt;/code&gt;“。&lt;/p&gt;

&lt;h2 id=&quot;常量传播&quot;&gt;常量传播&lt;/h2&gt;

&lt;p&gt;常数折叠和传播通常一起使用，以实现许多简化和减少，通过迭代交织，直到不再发生变化。所以继续来看看常量传播。&lt;/p&gt;

&lt;p&gt;常数传播是在编译时将已知常数的值替换到表达式中的过程。这些常量包括上面定义的常量，以及应用于常量值的内在函数。考虑一下下面的伪代码。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;把 x （传播propagate）带入后，变成&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;继续传播，带入后的结果为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;组合起来使用&quot;&gt;组合起来使用&lt;/h2&gt;

&lt;p&gt;举个维基百科例子，从至少需要3个寄存器和7条基础指令（别问，瞎猜的，具体数量还要取决于硬件的设计），一个分支，优化到只有一个寄存器的过程：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用一次常量的传播，然后是常量的折叠，得到&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//折叠+传播&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 折叠&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再重复2次：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 传播+折叠&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 传播+折叠&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于a和b已经被简化为常数，并且它们的值在它们出现的地方都被替换了，编译器现在应用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;死代码消除法&lt;/code&gt;来丢弃它们，进一步减少了代码。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们肉眼就能看出来，if 这个分支里面始终都会别执行，难道编译器不行？别急，继续优化。&lt;/p&gt;

&lt;p&gt;在上面的代码中，根据编译器框架，它可以是1或任何其他布尔结构，而不是true。通过传统的常数传播，我们只能得到这么多的优化。它不能改变程序的结构。&lt;/p&gt;

&lt;p&gt;还有一个类似的优化，叫做稀疏条件常量传播，它根据if条件选择适当的分支，编译器现在可以检测到if语句总是评估为真，c本身可以被消除，进一步缩小代码。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个伪代码构成了一个函数的主体，编译器可以进一步利用它评估为常数整数4的知识来消除对函数的不必要的调用，从而产生进一步的性能提升。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;常数传播是在编译器中使用到达定义分析结果实现的。如果所有变量的达成定义都是相同的赋值，而这个赋值又给变量分配了一个相同的常数，那么这个变量就有一个常数值，可以用这个常数来代替。&lt;/p&gt;

&lt;p&gt;常数传播也可以使条件分支简化为一个或多个无条件语句，此时条件表达式可以在编译时被评估为真或假，以确定唯一可能的结果。&lt;/p&gt;

&lt;p&gt;顺便推荐一个编译器优化方案的一个集合，还提供了一些测试集，对于编译器开发的同事来说，太棒了。我要推荐给你，知行合一，来卷起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;看名字就知道是什么： http://compileroptimizations.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ps.最近有个尴尬的烦恼，打「什么」2个字的时候，总是出现「SM」……
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/xB9W7B.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://compileroptimizations.com/category/constant_folding.htm&quot;&gt;Constant Folding&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;Constant Folding&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://oi-wiki.org/lang/optimizations/&quot;&gt;编译优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36287943/article/details/104974597&quot;&gt;编译优化之 - 常量传播入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/15/compiler-const-folding/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/15/compiler-const-folding/</guid>
        
        <category>gcc</category>
        
        <category>compiler</category>
        
        <category>constant</category>
        
        <category>optimization</category>
        
        
      </item>
    
      <item>
        <title>编译器优化 2 - ThinLTO</title>
        <description>&lt;h2 id=&quot;什么是编译器优化&quot;&gt;什么是编译器优化&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;保持语义不变的情况下，对程序运行速度、程序可执行文件大小作出改进&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;编译器优化（Compiler optimization）是指在编译器将源代码转化为可执行代码的过程中，通过对程序的分析和优化，使得生成的目标代码在执行速度、占用内存等方面都能够达到更好的效果。&lt;/p&gt;

&lt;p&gt;具体来说，编译器优化可以通过减少代码的重复计算、减少缓存未命中的情况以及减少不必要的寄存器使用等方式提高程序的执行效率，从而让程序的运行更快、更稳定。同时，优化也可以使得编译出来的目标代码更加紧凑，减少程序所占用的内存和磁盘空间。&lt;/p&gt;

&lt;p&gt;编译器优化的主要目标是提高程序的性能、优化目标代码的大小以及减少程序的资源占用。为了达到这些目标，编译器需要对源代码进行细致的分析，确定不必要的代码并去除，同时在编译过程中根据程序的表现不断进行优化调整，以逐步提高程序的性能。&lt;/p&gt;

&lt;p&gt;我们老大叫我们多看看在LLVM上优化，可以参考下GCC的优化方法。你们有没有什么好的方法？&lt;/p&gt;

&lt;h2 id=&quot;lto&quot;&gt;LTO&lt;/h2&gt;

&lt;p&gt;LTO（Link Time Optimization）是一种通过整个程序分析和跨模块优化来实现更好的运行时性能的方法。在编译阶段，clang会发出LLVM位码而不是对象文件。链接器会识别这些位码文件，并在链接过程中调用LLVM，以生成构成可执行文件的最终对象。LLVM实现加载所有输入的比特码文件，并将它们合并在一起以产生一个单一的模块。程序间分析（IPA）和程序间优化（IPO）在这个单体模块上连续进行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230313170728.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LTO有个缺点：这在实践中意味着LTO经常需要大量的内存（以一次容纳所有的IR），而且速度非常慢。而在通过-g启用调试信息的情况下，IR的大小和由此产生的内存需求会明显增大。即使没有调试信息，这对于非常大的应用程序，或者在内存受限的机器上进行编译，也是令人望而却步的。这也使得增量构建不那么有效，因为当任何输入源发生变化时，从LTO步骤开始的一切都必须重新执行。&lt;/p&gt;

&lt;h2 id=&quot;thinlto&quot;&gt;ThinLTO&lt;/h2&gt;

&lt;p&gt;ThinLTO 是一种新的方法，旨在像非LTO构建那样进行扩展，同时保留了全LTO的大部分性能成就。
在ThinLTO中，串行步骤是非常薄和快速的。这是因为它不是加载比特码和合并一个单一的单体模块来进行这些分析，而是利用每个模块的紧凑摘要来进行串行链接步骤中的全局分析，以及为后来的跨模块导入的函数位置索引。当模块在完全并行的后端进行优化时，函数导入和其他IPO转换将在以后进行。&lt;/p&gt;

&lt;p&gt;由ThinLTO全局分析实现的关键转换是函数导入，其中只有那些可能被内联的函数被导入到每个模块。这最大限度地减少了每个ThinLTO后端的内存开销，同时最大化了最有影响的跨模块优化机会。因此，IPO转换是在每个模块上用其导入的函数进行扩展。
ThinLTO的过程分为3个阶段。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;编译：与完全的LTO模式一样生成IR，但用模块摘要进行扩展。&lt;/li&gt;
  &lt;li&gt;thin link:thin 链接器插件层，结合摘要并进行全局分析&lt;/li&gt;
  &lt;li&gt;ThinLTO后端: 具有基于摘要的导入和优化的并行后端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230313171121.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个过程的关键因素是在第一阶段发出的摘要。这些摘要是使用比特码格式发布的，但设计成可以单独加载，而不涉及LLVMContext或任何其他昂贵的结构。每个全局变量和函数在模块摘要中都有一个条目。一个条目包含元数据，对它所描述的符号进行抽象。例如，一个函数被抽象为它的链接类型，它所包含的指令数量，以及可选的剖析信息（PGO）。此外，对另一个全局的每一个引用（采取的地址，直接调用）都被记录下来。这些信息可以在Thin link阶段建立一个完整的引用图，并利用全局总结信息进行后续快速分析。&lt;/p&gt;

&lt;p&gt;下面图片是LTO和ThinLTO的编译对比图；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230314084435.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ipo&quot;&gt;IPO&lt;/h2&gt;

&lt;p&gt;过程间分析（inter-procedural analysis）是一个多步骤的过程，是LTO分析过程中的重要部分，也是一个跨模块的分析过程。跨模块的优化功能实现最早在1987年（Link time optimization - MIPS），后来相继出现了过程间分析和转换，动态链接程序的优化（IPA + LTO）。&lt;/p&gt;

&lt;p&gt;GCC中的IPA包含的操作有： increase alignment、devirtualization、constant propagation、inline、pure/const analysis等。&lt;/p&gt;

&lt;p&gt;ICC中的IPO（Interprocedural Optimization）包含众多的优化，例如：Array dimension padding、Alias analysis、Constant propagation、Dead call deletion、Dead function elimination、Inlining、Structure splitting and field reordering、Whole program analysis等重要优化过程。优化选项配置为-ipo。&lt;/p&gt;

&lt;p&gt;比如inline内联优化。&lt;/p&gt;

&lt;h3 id=&quot;inline内联优化&quot;&gt;inline内联优化&lt;/h3&gt;

&lt;p&gt;内联（inline）优化就是把调用的函数放到调用的地方，避免函数调用和寄存器的分配，增加指令的数量。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 内联优化后&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;优化后，取消函数调用的好处&lt;/p&gt;

&lt;p&gt;1.它消除了函数调用过程中所需的各种指令：包括在堆栈或寄存器中放置参数，调用函数指令，返回函数过程，获取返回值，从堆栈中删除参数并恢复寄存器等。&lt;/p&gt;

&lt;p&gt;2.由于不需要寄存器来传递参数，因此减少了寄存器溢出的概率。当使用引用调用（或通过地址调用或通过共享调用）时，它消除了必须传递引用然后取消引用它们。&lt;/p&gt;

&lt;p&gt;除了有点，也有缺点：优化后的执行程序包变大。还有一些特定情况，内联将会造成很严重的后果，如递归函数的内联可能造成代码的无限inline循环。所以编译器在这些特殊情况下会拒绝内联，常见的包括虚调用，函数体积过大，有递归，可变数目参数，通过函数指针调用，调用者异常类型不同，declspec宏、使用alloca、使用setjump等。&lt;/p&gt;

&lt;p&gt;可以通过关键字：inline来实现内联优化。&lt;/p&gt;

&lt;p&gt;其实内联inline只是建议性的关键字，编译器并不一定会听你的，毕竟他比你更了解你的代码编译后是什么样子的，而所谓的内联也不单单是指inline这个关键字了，他本质上是一种编译器的优化方式。另外，在windows上平台我还经常能看到【forceinline】（GCC上的【always_inline】）这样的关键字，字面意思是强制内联。不过经过查阅，发现一般只是对代码体积不做限制了，或者说在Debug模式（不不开启优化的情况）下也会尽量按照开发者的意愿去内联。无论如何，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最终的决定权还是交给编译器去处理&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;死代码码消除-deadcode-elimination&quot;&gt;死代码码消除 (Deadcode Elimination)&lt;/h2&gt;

&lt;p&gt;故名思义，就是一段代码没用上就会被删去。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;233&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中，a和b实际在后面的代码中没有用到，所以编译的时候可以直接优化掉，将被转换为&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;学习东西要有耐心，不要着急，不要焦虑，否则会影响自己的信心。要循序渐进，关键是保持持续的学习动力。 编译器优化的内容很多，不必一次掌握。要逐个理解每个概念和原理。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://grin-compiler.github.io/&quot;&gt;GRIN Compiler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36287943/article/details/103930336&quot;&gt;编译优化之 - 过程间优化(IPA/IPO)入门&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50812510&quot;&gt;被知乎大佬嘲讽后的一个月，我重新研究了一下内联函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/docs/LinkTimeOptimization.html#example-of-link-time-optimization&quot;&gt;example-of-link-time-optimization&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html&quot;&gt;thinlto-scalable-and-incremental-lto&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/13/compiler-thinlto/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/13/compiler-thinlto/</guid>
        
        <category>gcc</category>
        
        <category>compiler</category>
        
        <category>optimization</category>
        
        
      </item>
    
      <item>
        <title>80 - 适者生存</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;今天看到冯大的一篇文章，&lt;a href=&quot;https://mp.weixin.qq.com/s/zN8vBAjrPh9nA0Q-kjnBWA&quot;&gt;我是这么看腾讯 T13 技术大佬被裁这事儿的&lt;/a&gt;，一个腾讯T13技术大佬被裁事件。&lt;/p&gt;

&lt;p&gt;技术专家在公司工作很多年而被裁，换了谁心里头都不舒服。对于当事人总结的被裁原因，往往又不是真正的原因，这就是所谓的当局者迷。&lt;/p&gt;

&lt;p&gt;作者给出了几个职场建议，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;包括低头干活，抬头看路，改变自己适应环境，以及让个人和公司相忘于江湖&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最近恰好听播客，接触到了一本书「高效能人士的7个习惯」,听名字就很鸡汤，但是里面对于职场新人来说，干货满满，豆瓣评分8.5。&lt;/p&gt;

&lt;p&gt;什么是彼得原理喃？&lt;/p&gt;

&lt;p&gt;指出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一个人在组织内部会得到晋升，直到不能胜任为止&lt;/code&gt;。也就是说，某个人在组织内部的管理层级，最终会达到自己无法胜任的位置。这意味着，即使一个人已经得到了晋升，但如果没有适当的培训和支持，他将无法胜任他晋升到的职位，会成为他的天花板。&lt;/p&gt;

&lt;p&gt;比如有一个程序员，他很擅长编写代码，并且在编写小型项目时表现优异。但是，当他被提升为高级软件工程师时，他可能会发现自己无法对应复杂和较大规模的项目，并且无法与团队进行沟通，或者无法承担管理职责。&lt;/p&gt;

&lt;p&gt;尽管他在代码方面很优秀，但是他可能会陷入自己的无能之境。他的上司可能会意识到他不能完成高级软件工程师的工作，并将他排除在项目外，或者将他降回到程序员或其他适合他的职位。&lt;/p&gt;

&lt;p&gt;但是在这里，有时候这个程序员可能也会变得太重要，团队已经习惯了他的存在，不能失去他，于是他就会继续留在这个职位上，直到他自己离开或者公司以某种方式解决这个问题。&lt;/p&gt;

&lt;p&gt;这个例子说明了在职场上，员工可能会被升迁到他们的无能之境，这不仅对他们本人不利，而且还对公司和团队产生负面影响。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5cW_LyfGRBoiYZYKi-eB4g&quot;&gt;想让我的方法更容易持续、更容易参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者的第六个年头的财务自由计划，她每年会整理过去的有价值的内容并定期更新分享给读者。文章重点在于如何获得10%的年度投资收益，从而达到财务自由的目标。作者强调了专业人士的专业知识的重要性，比如基金经理的投资建议等等。她建议投资者进行分散投资，使用能够跟踪表现最佳股票型基金平均收益的基金。作者还分享了她使用投资顾问和FOF来跟踪投资回报的经历和体验。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/E2KnibkYlVT4cgmd3QH1Kw&quot;&gt;无痛分娩，为什么还有 70% 产妇用不上？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;胡佳（化名）是一线城市三甲综合医院的麻醉科医生。和大家普遍想象的不同，胡佳所在的医院，产妇选择无痛分娩的比例是 100%。&lt;/p&gt;

&lt;p&gt;而在 19 年前，这个数据还只有 1%。据不完全统计，2004 年前仅有不足 1% 的国内产妇享受到分娩镇痛，即使在较发达地区分娩镇痛率仍不足 10%，而在边疆偏远地区，分娩镇痛更是一片空白。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwODQ3NjU5Ng==&amp;amp;mid=2247483986&amp;amp;idx=1&amp;amp;sn=995667b91c52664c265e5f65e2a8f59a&amp;amp;scene=58&amp;amp;subscene=0&quot;&gt;阿强买基金，为啥没人能卷走他的钱？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;把枯燥无趣的金融知识，用漫画的新式来传达，我觉得太有趣了。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cocktailpeanut.github.io/dalai/#/&quot;&gt;自动安装LLM模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在你的电脑上运行LLaMA的简单方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/camenduru/stable-diffusion-webui-colab&quot;&gt;stable diffusion的webui colab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过一个草图的形式就可以自动生成一个漂亮的图片，结合google colab,免费部署和使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://shots.so/&quot;&gt;shots截图工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各种样式的截图边框。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/microsoft/visual-chatgpt&quot;&gt;visual-chatgpt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;微软自家的Visual ChatGPT连接了ChatGPT和一系列的Visual Foundation模型，以便在聊天过程中发送和接收图像。&lt;/p&gt;

</description>
        <pubDate>Sat, 11 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/11/Survival-of-the-fittest/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/11/Survival-of-the-fittest/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
  </channel>
</rss>
