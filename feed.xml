<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>察说花园</title>
    <description>人生就是干</description>
    <link>https://blog.chiphub.top/</link>
    <atom:link href="https://blog.chiphub.top/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 11 Jun 2022 12:25:51 +0000</pubDate>
    <lastBuildDate>Sat, 11 Jun 2022 12:25:51 +0000</lastBuildDate>
    <generator>Jekyll v3.9.2</generator>
    
      <item>
        <title>41 - 保命重要</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;我发现有个奇怪的现象，订阅人数不是很多，才3位数，但是阅读量有时候4k+，难道是是转发阅读量很大？&lt;/p&gt;

&lt;p&gt;在此感谢大家的转发和帮助。&lt;/p&gt;

&lt;p&gt;本周的 newsletter 轻松一点，内容相对就少一点。主要是自己也想偷个懒，今天去陪孩子去参加了学校的足球比赛，被晒得像个红苹果一样。&lt;/p&gt;

&lt;p&gt;足球这个运动，不是根据人数来决定的，比如这种很无知的问题：我们14亿人口，居然选不出11个人来踢足球。&lt;/p&gt;

&lt;p&gt;拿领国日本来说，他们的足球在亚洲至少是数一数二的。他们为什么那么优秀？我觉得有一些文化影响也是非常重要的，从小就培养孩子们对这个运动的热爱。比如「足球小将」这种动漫，至少影响了不少80、90这一批人吧。&lt;/p&gt;

&lt;p&gt;一定是热爱，才能做的足够的优秀。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h2 id=&quot;认怂&quot;&gt;认怂&lt;/h2&gt;

&lt;p&gt;看了唐山打人事件之后，下面是大概的一个过程，网上也有很多视频和图片，我就不放了，太暴戾了……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;事情发生的时间是6月10日凌晨2点多，地点在河北唐山的一个烧烤店。监控视频显示，四名女子正在吃东西聊天，像是姐妹聚餐，有说有笑。这时店外走进来一名穿绿色夹克的男子，先是走到白衣女子身旁，摸背骚扰，当即被女子推开和质问，“干嘛呀你”、“有病啊”。夹克男又上来想有身体接触，女子好像甩出一句：去你妹。然后3个女孩和4个壮汉互殴起来了……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之前也有好多这样的事件，遇到这样的事情之后，如果我是当事人&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;大声呼叫「救命」&lt;/li&gt;
  &lt;li&gt;指一个现场的其他男性，一定要指明他，喊他帮你或者帮你「报警」&lt;/li&gt;
  &lt;li&gt;认怂，这种烧烤、啤酒场合，就是打架的好地方，建议先「认怂」，事后报警&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;希望患者能早日康复……&lt;/p&gt;

&lt;p&gt;上周家里来了好多亲戚，在桌上就说，今天我回来的路上，差点和一个司机干起来了。我以为是最近没有休息好，导致自己心情不好，脾气非常的大。&lt;/p&gt;

&lt;p&gt;桌上的年轻人都笑了一下，因为大家都经历过这样的事情，在那个时候基本上很难控制自己的情绪。各种脏话都能脱口而出，还有时候会出手。&lt;/p&gt;

&lt;p&gt;如果你有好的建议，可以给我分享下么？谢谢~&lt;/p&gt;

&lt;p&gt;但是老人们接着说，他们经常在手机等媒体上看到，万一对方车把事态升级，下来几个壮汉，把你毒打一顿，那怎么办？老人们怕我们吃亏，该忍就忍到起，但是确实忍不到呀……&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.theverge.com/2022/6/9/23161292/google-chrome-machine-learning-notification-phishing-preferences&quot;&gt;Chrome浏览器内置ML通知&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Google Chrome内置了网络钓鱼检测功能，可以扫描页面，看看它们是否与已知的虚假或恶意网站匹配（不仅使用URL，因为骗子旋转这些网站的速度比它跟上的速度要快）。而且，现在，这项技术正在变得更好。谷歌还表示，在Chrome 102中，它将使用完全在浏览器内运行的机器学习（不向谷歌或其他地方发送数据），以帮助识别主动通知许可请求的网站，并在弹出之前对其进行静音]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.xiaoyuzhoufm.com/episode/629cbe3a5cc037a5c6a7f6c3?s=eyJ1IjogIjYwZGU4ZDZlZTBmNWU3MjNiYmI0MzlhZCJ9&quot;&gt;大内密探，9周年的鬼故事&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;恐怖故事，做工精良，恐怖故事也是一种释放压力的不错方法。我之前没有关注他们，是大数据给我推送的，如果一个节目可以做9年，那真的是太厉害了……牛x&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://3dicons.co/&quot;&gt;3dicons&lt;/a&gt;
精心制作的开源3D 图标100% 免费供商业和个人使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://nomadlist.com/fire?age=33&amp;amp;interest=4&amp;amp;savings=50k&amp;amp;debt_rate=4&amp;amp;current_city=Gran+Canaria&amp;amp;current_city_latitude=28.1235459&amp;amp;current_city_longitude=-15.4362574&amp;amp;return_rate=1.04&amp;amp;income=3000&amp;amp;tax_rate=30&amp;amp;spending=1500&quot;&gt;财务自由的计算器&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以算算自己在对应的地方，挣多少钱，可以实现财务自由。目前济南排在第7位，往下就还是海口，成都没有上榜。&lt;/p&gt;

&lt;p&gt;如果自己在理财，应该可以提前退休。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;过去一周&quot;&gt;过去一周&lt;/h1&gt;

&lt;p&gt;最近有多个事情一起做。而且做的不开心，有时间就开始放空自己，刷几个短视频。没有用来开拓自己的阅读……&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;看书最重要的就是定好&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;固定的时间&lt;/code&gt;，比如每天早起20分钟，那这个时间就可以用阅读，可以做自己喜欢事情，就可以避免日后每天纠结到底啥时候读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;莫言 那些奇奇怪怪的事 - 20%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;适合和小孩一起阅读~&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;技术相关的书，大部分是电子书，因为可以随时的show me code。&lt;/li&gt;
  &lt;li&gt;方法、理论类的书籍，一般会停下来思考，提出问题、或者沉淀为自己的知识。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/06/11/life-is-important/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/06/11/life-is-important/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>40 - 朋友多好，还是少好？</title>
        <description>&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h2 id=&quot;本周话题&quot;&gt;本周话题&lt;/h2&gt;

&lt;p&gt;朋友，别看我平时像个逗比一样，其实我是很内向的。&lt;/p&gt;

&lt;p&gt;我的朋友很少，我个人感觉不超过一桌人，一年吃饭的话就更少了，不超过10次。&lt;/p&gt;

&lt;p&gt;我老婆经常说我没什么朋友，确实我身边朋友比较少，然后能约出来一起吃饭的，那就更少了。&lt;/p&gt;

&lt;p&gt;我是这么看待的，如果你要维持这个朋友关系，那可能要经常去维系这个关系，花时间去打点，然后这个时间我觉得花的不是很值，有那么几个知己已经足以。&lt;/p&gt;

&lt;p&gt;不过我和我老婆就形成鲜明的对比，他身边就有非常多的朋友。从我个人感觉来，这种人应该是比较寂寞的，因为他如果没有那样热闹的氛围，他可能很难沉浸下来去做某些东西。&lt;/p&gt;

&lt;p&gt;反而我感觉我更耐得住寂寞，也没有什么个人的生日宴会，个人的宝宝宴会……，我不喜欢和不熟的人一起吃饭，一起出去玩。这就是我的社交恐惧症。&lt;/p&gt;

&lt;p&gt;也有可能是个人的性格决定的。&lt;/p&gt;

&lt;h2 id=&quot;心胸宽广&quot;&gt;心胸宽广&lt;/h2&gt;

&lt;p&gt;我刚毕业出来工作的时候，老是跟老板对着干，想到能活到现在也是命大呀&lt;/p&gt;

&lt;p&gt;小领导叫我做什么，心想这还用你教我，我知道怎么做。&lt;/p&gt;

&lt;p&gt;当有人指出我的问题或者批判我，我当时第一反应可能会是怎么去对立的去反驳这个问题不去接纳，还有可能是更严重的是报复他。&lt;/p&gt;

&lt;p&gt;经过这些年的一个成长，对某人有益和无益的提出这个问题，我在心里面不可能是之前那种想法了，而是我有没有这种问题，然后如何去改变这个问题。&lt;/p&gt;

&lt;p&gt;我想想之前自己真的好low，不仅命大，而且命硬&lt;/p&gt;

&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;

&lt;p&gt;喜剧是什么？&lt;/p&gt;

&lt;p&gt;包括旨在通过引发笑声来表现幽默或有趣的话语或作品，尤其是在戏剧、电影、单口喜剧、电视、广播、书籍或任何其他娱乐媒介中。&lt;/p&gt;

&lt;p&gt;来自维基百科，喜剧是一种作品，意思就是作者用劳动换来的，所以我看到的舞台上，演员的表演都是一种呈现的结果。所以喜剧和幽默，以及这个人在线下的表现是不一样的。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SQ5xa6gPtYqCfaHLJikTCA&quot;&gt;给女儿的投资计划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，投资到底是投什么？&lt;/p&gt;

&lt;p&gt;买一家公司的股票，就是买入它的一部分所有权，成为了小股东，这家公司赚钱了，你也就能分到相应的一部分。&lt;/p&gt;

&lt;p&gt;最重要的我觉得是找到好的公司，然后有足够的耐心来等待。后面这一步我能做到，前面哪一步说实话是挺难的。&lt;/p&gt;

&lt;p&gt;股票的价值是这家公司未来现金流的折现，这个现金流跟公司的利润正相关。买股票最终能不能赚到钱，本质上是看这家公司在你买入之后余下的生命里能不能持续地赚钱。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kristerw.github.io/2022/05/24/branchless/&quot;&gt;编译器里面的move和branch指令的解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者是做GPU编译器的，可以关注一下。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.shalerb.org/&quot;&gt;Shale&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Shale 是用于 JSON、 YAML 和 XML 的 Ruby 对象映射器和序列化器。允许您解析 JSON、 YAML 和 XML 数据，并将其转换为 Ruby 数据结构，以及将数据结构序列化为 JSON、 YAML 或 XML。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mazzo.li/posts/fast-pipes.html&quot;&gt;Linux 管道的速度优势&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文探讨了Linux如何实现Unix管道。它首先使用吞吐量约为3.5GiB/s的程序，然后对其进行优化，直到其性能提高二十倍。需要具备C语言的基本知识。链接了包含文章代码的GitHub存储库。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;过去一周&quot;&gt;过去一周&lt;/h1&gt;

&lt;p&gt;本周的思考时刻：如何计划自己的行动？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;写下自己要完成的计划&lt;/li&gt;
  &lt;li&gt;在自己放松的时候就嫩刚看到的这个提醒(比如设置为屏保，当玩耍手机的是就可以看到)&lt;/li&gt;
  &lt;li&gt;然后每天进步一点，给自己一个反馈，有多巴胺更能坚持下去&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下周思考：NA&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;看书最重要的就是定好&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;固定的时间&lt;/code&gt;，比如每天早起20分钟，那这个时间就可以用阅读，可以做自己喜欢事情，就可以避免日后每天纠结到底啥时候读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;莫言 - 奇奇怪怪的那些事 - 5%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要是培养孩子的读书习惯，一种以故事的方式来培养习惯，我个人觉得是一种不错的方式。&lt;/p&gt;

&lt;p&gt;如果有你有好的方式，可以给我回信分享一下么？谢谢~&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;技术相关的书，大部分是电子书，因为可以随时的show me code。&lt;/li&gt;
  &lt;li&gt;方法、理论类的书籍，一般会停下来思考，提出问题、或者沉淀为自己的知识。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/06/04/what-is-friend/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/06/04/what-is-friend/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>用谷歌云服务器免费跑 cuda 代码</title>
        <description>&lt;h2 id=&quot;什么是-cuda&quot;&gt;什么是 CUDA？&lt;/h2&gt;

&lt;p&gt;CUDA 是 Nvidia 为并行计算平台和应用程序编程接口创建的一个模型。CUDA 是 NVIDIA 的并行计算架构，通过利用 GPU 的能力，可以大幅度提高计算性能。&lt;/p&gt;

&lt;p&gt;CUDA 代码不会在 AMD CPU 或者 Intel HD Graphics 上运行，除非你的机器里有 NVIDIA 的硬件。在 Colab 上，你可以利用 NVIDIA 的 GPU，以及一个预装了 Tensorflow 和其他 ML/DL 工具的功能齐全的 Jupyter note。&lt;/p&gt;

&lt;h3 id=&quot;第1-打开colab&quot;&gt;第1: 打开colab&lt;/h3&gt;

&lt;p&gt;然后在runtime-&amp;gt; change type里面修改硬件加速为GPU。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://colab.research.google.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/OXy9Wi.png&quot; alt=&quot;OXy9Wi&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;第二检测nvcc版本&quot;&gt;第二：检测nvcc版本&lt;/h3&gt;

&lt;p&gt;一般都是安装了cuda的，直接执行nvcc来查看版本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/SzsWT1.png&quot; alt=&quot;SzsWT1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-安装插件&quot;&gt;3. 安装插件&lt;/h3&gt;

&lt;p&gt;为了nvcc能运行，需要安装一个插件，识别为cuda代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/5pgVlU.png&quot; alt=&quot;5pgVlU&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!pip install git+https://github.com/andreinechaev/nvcc4jupyter.git
%load_ext nvcc_plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-运行cuda&quot;&gt;4. 运行cuda&lt;/h3&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;%%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cuda_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World from GPU!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cuda_hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;cudaDeviceSynchronize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/VGzSId.png&quot; alt=&quot;VGzSId&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;read-more&quot;&gt;Read more&lt;/h2&gt;

&lt;p&gt;https://gist.github.com/chasays/81994504fe154f6cd9f799323e331ca8&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/06/02/run-cuda-with-free-cloud/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/06/02/run-cuda-with-free-cloud/</guid>
        
        <category>cuda</category>
        
        
      </item>
    
      <item>
        <title>LLVM LibFuzzer介绍和实践</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下面是自己学习libFuzzer过程中，记录的文档，欢迎交流和指正。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Fuzzing 是一种软件测试方法，包括将格式不正确的数据作为输入传递给程序，并监视其是否存在不正确的行为。今天 fuzzing 是发现软件安全问题的最有效的方法之一。2014年第一个覆盖引导模糊器Fuzzy Lop。这开创了现代市场上的模糊解决方案和技术。&lt;/p&gt;

&lt;h2 id=&quot;什么是libfuzzer&quot;&gt;什么是LibFuzzer&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;LibFuzzer is in-process, coverage-guided, evolutionary fuzzing engine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LibFuzzer与被测库链接，并通过特定的模糊化入口点（又称“目标函数 target function”）将模糊化输入提供给库；然后，模糊器跟踪到达的代码区域，并在输入数据的主体上生成不同的参数组合，以最大限度地提高代码覆盖率。libFuzzer的代码覆盖率信息由LLVM的SanitizerCoverage工具提供。&lt;/p&gt;

&lt;p&gt;提供：&lt;/p&gt;

&lt;p&gt;简单来说就是通过与要进行fuzz的库连接，并将libfuzzer生成的输入通过模糊测试进入点(fuzz target)喂给要fuzz的库进行fuzz testing。同时fuzzer会跟踪哪些区域的代码已经被测试过的，并且根据种料库的输入进行变异来使得代码覆盖率最大化。代码覆盖率的信息是由LLVM’s SanitizerCoverage插桩提供的&lt;/p&gt;

&lt;p&gt;需要注意的是这几个libfuzzer的特性：in-process指进程内。即libfuzzer在fuzz时并不是产生出多个进程来分别处理不同的输入，而是将所有的测试数据放入进程的内存空间中。coverage-guided指覆盖率指导的。即会进行代码覆盖率的计算，正如定义所说的使得不断增大代码覆盖率。evolutionary是指libfuzzer是进化型的fuzz，结合了产生和变异两种形式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/5e2siO.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;举例-fuzzing-test&quot;&gt;举例 fuzzing-test&lt;/h2&gt;

&lt;p&gt;创建一个文件，fuzz_target.cc, 这个内容如下，记得不要使用使用main等作为函数名。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// fuzz_target.cc&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LLVMFuzzerTestOneInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;DoSomethingInterestingWithMyAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Non-zero return values are reserved for future use.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMFuzzerTestOneInput&lt;/code&gt; 函数是我们要实现的接口函数，他的两个参数Data(libfuzzer的测试样本数据)，size(样本数据的大小)。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DoSomethingInterestingWithMyAPI&lt;/code&gt; 函数即我们实际要进行fuzz的函数。&lt;/p&gt;

&lt;p&gt;编译这个文件，命令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clang++ -g -O1 -fsanitize=fuzzer,address fuzz_target.cc -o fuzzer_target&lt;/code&gt; ，这里的clang是我们用llvm编译出来的，如果用的其他方式会报错。&lt;/p&gt;

&lt;p&gt;参数的意思：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-g 可选参数，保留调试符号。&lt;/li&gt;
  &lt;li&gt;-O1 指定优化等级为1，对应的还有O0 (optimize 0,1,2)，以及OS(optimize size)使用后binary大小会变小。&lt;/li&gt;
  &lt;li&gt;-fsanitize 指定sanitize， 值有几种：fuzzer,address，memory(单独使用，检查内存)，undefined(移除、未定义等)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这一步骤整体过程就是通过clang的-fsanitize=fuzzer选项可以启用libFuzzer，这个选项在编译和链接过程中生效，实现了条件判断语句和分支执行的记录，通过生成不同的测试样例然后能够获得代码的覆盖率情况，最终实现所谓的fuzz-testing。&lt;/p&gt;

&lt;p&gt;注意：编译的选项会影响fuzzer的效率，比如下面就是一个点。我也不知道有哪些，遇到问题就在网上搜吧，一定会有结果的。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;clang编译的时候，参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-fno-omit-frame-pointer &lt;/code&gt;对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不需要栈指针的函数就不在寄存器中保存指针&lt;/code&gt;，因此可以忽略存储和检索地址的代码，同时对许多函数提供一个额外的寄存器。所有”-O”级别都打开它，但仅在调试器可以不依靠栈指针运行时才有效。在AMD64平台上此选项默认打开，但是在x86平台上则默认关闭。建议显式的设置它。&lt;/li&gt;
  &lt;li&gt;gline-tables-only:表示使用采样分析器， 在应用程序执行时，抽样探查器用于收集运行时信息(如硬件计数器)。它们通常非常有效，并且不会引起大量的运行时开销。分析器收集的示例数据可用于编译期间，以确定代码中执行最多的区域是什么，在编译器可以使用分析信息之前，代码需要在分析器下执行。这也对提高我们fuzz效率很重要。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如常用的编译命令：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clang++ -g -O2 -fno-omit-frame-pointer -gline-tables-only -fsanitize=address,fuzzer-no-link test.cc -o test&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;写一个fuzz-测试函数&quot;&gt;写一个fuzz 测试函数&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;准备被测文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如有一个头文件， test.h, 里面有一个FuzzFunction1的函数&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FuzzFunction1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'F'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'U'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'Z'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'Z'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;写测试函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在要对着头里面里面的FuzzFunction1函数进行测试，编一个测试接口,test.cc，&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;test.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C&quot;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LLVMFuzzerTestOneInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint8_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;FuzzFunction1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，data和size和头文件里面的类型是一致的。如果是bool类型的，记得false和true，都要遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool bool_flag[] = {true, false}&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;编译测试函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只有就完成了，然后编译下面的测试接口函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clang++ -g -std=c++11 -fsanitize=fuzzer,address test.cc  -o test&lt;/code&gt;.,生成一个test的执行文件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个corpus(语料库，可以想象为一个函数的参数，各种参数的组合)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在未使用语料库的情况下就得到了crash实属意料之外，如果我们在使用字典的下情况仍然暂时未得到crash，另一个方法可以去寻找一些有效的输入语料库。因为libfuzzer是进化型的fuzz，结合了产生和变异两个发面。如果我们可以提供一些好的seed，虽然它本身没法造成程序crash，但libfuzzer会在此基础上进行变异，就有可能变异出更好的语料，从而增大程序crash的概率。具体的变异策略需要我们去阅读libfuzzer的源码或者些相关的论文。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;corpus
./test corpus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;corpus 是我们提供的语料库。理想情况下，该语料库应该为被测代码提供各种有效和无效的输入，模糊器基于当前语料库中的样本输入生成随机组合。&lt;/p&gt;

&lt;p&gt;如果组合触发了测试代码中先前未覆盖的路径的执行，则该组合参数将保存到语料库中以供将来变更。&lt;/p&gt;

&lt;p&gt;当然LibFuzzer也可以没有任何初始seed的情况下工作，但如果受测试的库接受复杂的结构化输入，则会因为随机产生的样例不易符合导致效率降低。&lt;/p&gt;

&lt;p&gt;合并corpus，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./test -merge=1 corpus_min corpus&lt;/code&gt;, 这样，corpus_min和corpus将会存放到新的corpus精简后的输入样例。&lt;/p&gt;

&lt;p&gt;执行的时候，我们一般会看到如下信息&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜  04 Rik:&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ✗ ./test corpus
INFO: Seed: 2222548757
INFO: Loaded 1 modules   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;35 inline 8-bit counters&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 35 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x7f7120, 0x7f7143&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 
INFO: Loaded 1 PC tables &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;35 PCs&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 35 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x5b7a68,0x5b7c98&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 
INFO:        0 files found &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;corpus1
INFO: &lt;span class=&quot;nt&quot;&gt;-max_len&lt;/span&gt; is not provided&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
&lt;span class=&quot;c&quot;&gt;#2    INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 27Mb&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#3    NEW    cov: 4 ft: 4 corp: 2/4b lim: 4 exec/s: 0 rss: 27Mb L: 3/3 MS: 1 CMP- DE: &quot;\x00\x00&quot;-&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#1190    NEW    cov: 5 ft: 5 corp: 3/7b lim: 14 exec/s: 0 rss: 27Mb L: 3/3 MS: 2 ChangeBinInt-CMP- DE: &quot;F\x00&quot;-&lt;/span&gt;
……………………
&lt;span class=&quot;nv&quot;&gt;artifact_prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'./'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Seed 这个seed，就是./test -seed=xxx可以指定的随机seed&lt;/li&gt;
  &lt;li&gt;max_len  测试输入的最大长度&lt;/li&gt;
  &lt;li&gt;cov  代码覆盖率，我们的语料库达到的代码块总数&lt;/li&gt;
  &lt;li&gt;corp   语料库中的文件数量及其总大小&lt;/li&gt;
  &lt;li&gt;exec/s  每秒模糊迭代次数(在运行时间长于 &amp;lt; = 1秒的情况下有用)&lt;/li&gt;
  &lt;li&gt;rss  存储在物理内存中的进程内存量&lt;/li&gt;
  &lt;li&gt;./crash-xxx 这个就是用来复现问题的文件，方便吧&lt;/li&gt;
  &lt;li&gt;INITED fuzzer已完成初始化，其中包括通过被测代码运行每个初始输入样本。&lt;/li&gt;
  &lt;li&gt;READ fuzzer已从语料库目录中读取了所有提供的输入样本。&lt;/li&gt;
  &lt;li&gt;NEW fuzzer创建了一个测试输入，该输入涵盖了被测代码的新区域。此输入将保存到主要语料库目录。&lt;/li&gt;
  &lt;li&gt;pulse fuzzer已生成 2的n次方个输入（定期生成以使用户确信fuzzer仍在工作）。&lt;/li&gt;
  &lt;li&gt;REDUCE fuzzer发现了一个更好（更小）的输入，可以触发先前发现的特征（设置-reduce_inputs=0以禁用）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后的一个crash文件， 这样我们就可以有针对性的对程序进行动态调试，利用造成crash的输入回溯出漏洞的细节。&lt;/p&gt;

&lt;h3 id=&quot;如何理解fuzzer的输出结果&quot;&gt;如何理解fuzzer的输出结果&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#17458 REDUCE cov: 7 ft: 7 corp: 5/14b lim: 170 exec/s: 0 rss: 29Mb L: 4/4 MS: 1 EraseBytes-&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;指尝试了17458个输入，成功发现了5个样本（放入语料库）大小为14b，共覆盖了7个代码块，占用内存29mb，变异操作为EraseBytes-&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/dgLG09.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;要使用libfuzzer的功能&quot;&gt;要使用libfuzzer的功能&lt;/h2&gt;
&lt;p&gt;就需要再llvm里面变异compiler-rt，然后可以使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clang++ -fsanitizer=Address xx.cc&lt;/code&gt; 在compiler-rt目录下有一些example cc的文件&lt;/p&gt;

&lt;h2 id=&quot;编译llvm-mc-assemble-fuzzer&quot;&gt;编译llvm-mc-assemble-fuzzer&lt;/h2&gt;

&lt;p&gt;这个是汇编器的，还有其他的，
编译这个用之前的编译的llvm里面的clang，就需要替换为这个，用flag=cmake_c_compiler=xxx/clang
而且目录不能是同一个，不然cmake会失败。&lt;/p&gt;

&lt;h2 id=&quot;fuzzer的dict&quot;&gt;fuzzer的dict&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;提高我们fuzz的效率&lt;/code&gt;，这其中一个办法就是使用字典。&lt;/p&gt;

&lt;p&gt;我们知道基本上所有的程序都是处理的数据其格式是不同的，比如 xml文档， png图片等等。这些数据中会有一些特殊字符序列 （或者说关键字）， 比如在xml文档中就有CDATA，&amp;lt;!ATTLIST等，png图片就有png 图片头。如果我们事先就把这些字符序列列举出来吗，fuzz直接使用这些关键字去组合，就会就可以减少很多没有意义的尝试，同时还有可能会走到更深的程序分支中去。&lt;/p&gt;

&lt;p&gt;比如下面就是xml.dict里面的内容，xml一般有encoding、version、href等，用这些来组合，比其他的组合更高效，用例少，速度快，更精准。&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;attr_encoding=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; encoding=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;attr_generic=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; a=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;attr_href=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; href=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;attr_standalone=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; standalone=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;attr_version=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; version=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行的时候指定dict，用参数-dict &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./test -max_total_time=60 -print_final_stats=1 -dict=./xml.dict corpus&lt;/code&gt;,如果corpus太多，可以用merge来精简为一个。&lt;/p&gt;

&lt;p&gt;文章太长了。主要是这个工具太强大了。&lt;/p&gt;

&lt;h2 id=&quot;最后的进阶&quot;&gt;最后的进阶&lt;/h2&gt;

&lt;p&gt;下面是关于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一些链接库的选择以及插桩编译时的一些参数的设置，还有max_len的设置对我们最后fuzz结果的影响&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;编译的插桩参数&quot;&gt;编译的插桩参数&lt;/h3&gt;

&lt;p&gt;插桩的参数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-fno-omit-frame-pointer -gline-tables-only&lt;/code&gt;，这2个前面提到过了，再来介绍一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fuzzer-no-link&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果修改大型项目的CFLAGS，它也需要编译自己的主符号的可执行文件，则可能需要在不链接的情况下仅请求检测，即fuzzer-no-link强制在链接阶段不生效。&lt;/p&gt;

&lt;p&gt;介绍一些新的参数，是关于ld的。&lt;/p&gt;

&lt;p&gt;比如编译命令：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -O2 -fno-omit-frame-pointer -gline-tables-only \
-fsanitize=address,fuzzer-no-link -fsanitize-address-use-after-scope test.cc \
 -Wl,--whole-archive xxx/.libs/libpcre2-8.a xx/.libs/libpcre2-posix.a \
 -Wl,-no-whole-archive -fsanitize=fuzzer -o test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数：–whole-archive和–no-whole-archive是ld专有的命令行参数，clang++并不认识，要通过clang++传递到ld，需要在他们前面加-Wl。–whole-archive可以把 在其后面出现的静态库包含的函数和变量输出到动态库，–no-whole-archive则关掉这个特性。&lt;/p&gt;

&lt;h3 id=&quot;执行的max_len的参数&quot;&gt;执行的max_len的参数&lt;/h3&gt;

&lt;p&gt;max_len一般情况下，越大获得的corpus就越多，就越容易挖掘出bug。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./test ./corpus1 -print_final_stats=1 -max_len=500 -max_total_time=100&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解释，运行test，长度为500，并打印最后的结果，执行事假哪位100s，执行的corpus保存到corpus1里面。&lt;/p&gt;

&lt;p&gt;编译llvm fuzz参考：https://github.com/google/oss-fuzz/blob/master/projects/llvm/build.sh&lt;/p&gt;

&lt;p&gt;cmake -GNinja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=On -DLLVM_ENABLE_WERROR=On -DLLVM_USE_SANITIZER=Address -DLLVM_USE_SANITIZE_COVERAGE=On -DCMAKE_C_COMPILER=/usr/local/bin/clang ../llvm&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake &lt;span class=&quot;nt&quot;&gt;-GNinja&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Release ../&lt;span class=&quot;nv&quot;&gt;$LLVM&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clang;libcxx;libcxxabi;compiler-rt;lld;clang-tools-extra&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_ASSERTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ON &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DCMAKE_C_COMPILER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CC&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DCMAKE_CXX_COMPILER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CXX&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DCMAKE_C_FLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DCMAKE_CXX_FLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CXXFLAGS&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CMAKE_FUZZING_CONFIG&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DLLVM_NO_DEAD_STRIP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ON &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DLLVM_USE_SANITIZER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LLVM_SANITIZER&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;WebAssembly &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-DCOMPILER_RT_INCLUDE_TESTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;OFF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;read-more&quot;&gt;Read more&lt;/h2&gt;

&lt;p&gt;https://llvm.org/docs/LibFuzzer.html&lt;/p&gt;

&lt;p&gt;https://blog.haboob.sa/blog/applying-fuzzing-techniques-against-pdftron-part-2&lt;/p&gt;

&lt;p&gt;https://www.moritz.systems/blog/an-introduction-to-llvm-libfuzzer/&lt;/p&gt;

&lt;p&gt;https://github.com/Dor1s/libfuzzer-workshop&lt;/p&gt;

&lt;p&gt;https://www.anquanke.com/post/id/224823&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/06/01/llvm-fuzz/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/06/01/llvm-fuzz/</guid>
        
        <category>LLVM</category>
        
        
      </item>
    
      <item>
        <title>安装WSL错误0x80072f7d，解决办法</title>
        <description>&lt;h2 id=&quot;现象&quot;&gt;现象&lt;/h2&gt;

&lt;p&gt;wsl2安装ubuntu的时候，提示错误0x80072f7d&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:&lt;span class=&quot;se&quot;&gt;\W&lt;/span&gt;indows&lt;span class=&quot;se&quot;&gt;\s&lt;/span&gt;ystem32&amp;gt;wsl &lt;span class=&quot;nt&quot;&gt;--install&lt;/span&gt;
Installing: Windows Subsystem &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;Linux
Windows Subsystem &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;Linux has been installed.
Downloading: WSL Kernel
A error was encountered during installation, but installation may &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Component: &lt;span class=&quot;s1&quot;&gt;'WSL Kernel'&lt;/span&gt; Error Code: 0x80072f7d
Downloading: Ubuntu
The requested operation is successful. Changes will not be effective &lt;span class=&quot;k&quot;&gt;until &lt;/span&gt;the system is rebooted.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;

&lt;p&gt;网上找到的解决方案都是先安装wsl linux kernel，就可以解决，我安装之后，还是提示错误，进度条卡在某一个点50%+，网上看一了下，有卡在不同位置的.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先是安装 wsl2 linux-kernel，下面是x86的安装包，
    &lt;blockquote&gt;
      &lt;p&gt;https://docs.microsoft.com/en-us/windows/wsl/install-manual#step-4—download-the-linux-kernel-update-package&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;然后是开启虚拟化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;直接在powershell 执行下面的命令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All&lt;/code&gt;，记得启动完了，之后会提示重启.&lt;/p&gt;

&lt;p&gt;也可以通过windows 功能里面来手动安装和启动，参考下面的页面&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;下载wsl安装包&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在某些情况下，你可能无法（或不想）使用 Microsoft Store 安装 WSL Linux 发行版。 你可能正在运行不支持 Microsoft Store 的 Windows Server 或长期服务 (LTSC) 桌面操作系统 SKU，或者你的公司网络策略和/或管理员不允许在你的环境中使用 Microsoft Store。 在这些情况下，虽然 WSL 本身可用，但你可能需要直接下载 Linux 发行版。&lt;/p&gt;

&lt;p&gt;下面是Ubuntu18.04的发行包&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://aka.ms/wsl-ubuntu-1804&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;安装发行包&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下载了发行版后，导航到包含下载内容的文件夹，并在该目录中运行以下命令，其中 app-name 是 Linux 发行版 .appx 文件的名称。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Add-AppxPackage .\app_name.appx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者是Appx 包下载完成后，可以通过双击 appx 文件开始运行新发行版。 （命令 wsl -l 不会在此步骤完成之前显示发行版已安装）。&lt;/p&gt;

&lt;p&gt;祝你使用wsl愉快，有时候GPU driver等，导致你的cuda代码在wsl跑步起来，也有可能是这个导致的.&lt;/p&gt;

&lt;h2 id=&quot;read-more&quot;&gt;Read more&lt;/h2&gt;

&lt;p&gt;https://superuser.com/questions/1678737/component-wsl-kernel-error-code-0x80072f7d-on-wsl-install&lt;/p&gt;

&lt;p&gt;https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#downloading-distributions&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/05/30/wsl-install-error-0x80072f7d/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/05/30/wsl-install-error-0x80072f7d/</guid>
        
        <category>wsl</category>
        
        
      </item>
    
      <item>
        <title>Linux 配置 xx search history</title>
        <description>&lt;p&gt;这个是为我自己记录配置的，因为我换了环境之后，总是忘记怎么配置.&lt;/p&gt;

&lt;p&gt;喜欢linux、unix的终端，非常的方便.&lt;/p&gt;

&lt;p&gt;但是快速的的找到某一个历史命令，有很多种途径，有没有更快速的方法喃&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;history&lt;/td&gt;
          &lt;td&gt;grep xxx 这个太慢了&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;ctrl+r 输入之前输入过的命令，会有提示&lt;/li&gt;
  &lt;li&gt;输入之前命令的前半部分，然后按向上、向下箭头来快速找到&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我喜欢最后一种，配置方式如下，加到自己的inputrc里面即可.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\e&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[A&quot;&lt;/span&gt;: history-search-backward
&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\e&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[B&quot;&lt;/span&gt;: history-search-forward
&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\C&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-p&quot;&lt;/span&gt;: history-search-backward
&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\C&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-n&quot;&lt;/span&gt;: history-search-forward

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面配置的意思是： 箭头向上、下或者ctrl+p、n也可以用. p和n的是previous、next的缩写.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/05/30/config-linux-forward-history-search/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/05/30/config-linux-forward-history-search/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Keep Health</title>
        <description>
&lt;hr /&gt;
&lt;p&gt;layout: post
title: “39 - 保持健康”
subtitle: ‘2022-05-20’ 
author: “叉叉敌”
header-style: text
tags:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;newsletter&quot;&gt;Newsletter&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;我经常不知道如何写newsletter的开头，有时候就写最近的天气，或者最近的热点。&lt;/p&gt;

&lt;p&gt;你没看错，都是最近相关的。但是有个问题，我们大部分国人都没有养成看邮件的习惯，所以一般不是每天都会去看邮箱里面的邮件，就会导致看到这一篇newsletter，有可能已经是过了一段时间了，有可能是一个月，有可能是几个礼拜。&lt;/p&gt;

&lt;p&gt;没用太大的意义，除了字数。&lt;/p&gt;

&lt;p&gt;我后面就不写最近相关的，或者是就写自己的一些感悟。&lt;/p&gt;

&lt;p&gt;为了排版，这里本来应该有一张tech相关的图片，由于我的文章会通过github-actions，自动推送到微信公众号平台。图片用的github的图床，cdn用的是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdn.jsdelivr.net&lt;/code&gt;，但是国内最近屏蔽了这个网址，导致获取图片内容失败了，所以没有图片，抱歉，就是这么一段话了，后续钱足够的话，准备用其他云服务器的图床 。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h2 id=&quot;保持健康&quot;&gt;保持健康&lt;/h2&gt;

&lt;p&gt;上周老婆诊断胆结石，做了手术，就等着恢复吧。&lt;/p&gt;

&lt;p&gt;看了网上的介绍，胆结石大概有2个成因，一个是遗传，这个也是我们没法改变的，还有大概率原因一个是摄入高蛋白、高脂肪，缺乏运动。&lt;/p&gt;

&lt;p&gt;所以身体要紧，锻炼最好时机是几年前，还有就是现在 ~， 跟着刘畊宏跳起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;胆囊结石形成的原因目前大家没有一个定论，其中最主要的还是一个叫胆固醇过多的一个理论。大家知道胆囊胆汁里头有三个主要的成分，当然最主要的还是水，其次就是胆固醇、胆汁酸和卵磷脂。那么当这三种物质的配比达到一定配比的时候，胆固醇的这个溶解度是相对是最大的。当然胆固醇增多或者其它的配置失衡，会导致胆固醇从这个液态变成小的结晶体，然后慢慢形成一个胆囊结石的状态。那么这个是大家现在比较公认的一个理论。另外呢，还有一个就是说咱们的这个胆囊功能的问题，比如说胆囊排空功能的有问题了，胆囊长期处于这种淤胀状态，胆囊内的胆汁没法排出，这种状态下淤滞的胆汁也容易形成结石，这是目前比较常见的一些原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给我有2个启发&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;第一个是健康，尽早、多做对身体有好处的运动，保持健康&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;第二个是有病，尽早去能力范围内，医资力量好一点的地方&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最开始在我们小县城，也是三甲医院，那边的医生诊断就是胆囊炎，没有结石，就是输消炎的药，结果输了就是完全效果。&lt;/p&gt;

&lt;p&gt;来成都这边之后，重新检查之后，发现是结石掉到胆管里面了，已经堵塞胆管了……&lt;/p&gt;

&lt;h2 id=&quot;搞钱的目的&quot;&gt;搞钱的目的&lt;/h2&gt;

&lt;p&gt;你心中或者是你的经历中，有没有用钱非常愉快的时刻，可以分享一下么？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;钱只是我们改善生活的一种桥梁，一种途径，如果是钱是合理合法的，那我们就尽情的去搞，但是千万不要做违法的事情。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我来分享一次，最近用钱用的非常爽的时刻。&lt;/p&gt;

&lt;p&gt;记得我用钱最愉快的时刻，就是前段时间(快一年了吧)去广西涠洲岛，那里的海鲜。&lt;/p&gt;

&lt;p&gt;我们当时去还不是丰收期，就是说海鲜和内地比起来，价格差不了多少，也不便宜。&lt;/p&gt;

&lt;p&gt;吹着温热的海风，听着海水拍打海岸的声音，偶尔也听到几声海鸥的叫声，同时也闻到椒盐味的那种鲜香，能大快朵颐，不像平时在家，海鲜的量不太多，也没那么好。&lt;/p&gt;

&lt;p&gt;而且它的海鲜非常的新鲜而且非常饱满，个头也非常大，特别是皮皮虾，总体下来就是吃的爽，吃的非常的痛快&lt;/p&gt;

&lt;h2 id=&quot;旅行的目的&quot;&gt;旅行的目的&lt;/h2&gt;

&lt;p&gt;做一次长途旅行。这种旅行的目的不是为了玩，而是为了增加认知。&lt;strong&gt;最好的旅行会让你领悟到，世界之外还有世界，生活总是有其他可能，人类社会长期中总是服从熵增原理。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我之前大部分旅行都是国内。&lt;/p&gt;

&lt;p&gt;如果只考虑开拓见闻、增广心灵，国外旅行要比国内旅行的收获更大，更能让你感受世界的多样性。&lt;/p&gt;

&lt;p&gt;穷国比富国有意思，我去过东南亚小国家，城里的交通工具大部分都是吐吐车&lt;/p&gt;

&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;

&lt;p&gt;摆脱坏习惯之后省下来的时间，可以用来做你喜欢的事，也可以用来提升工作效率，还可以用来加深人际关系，或是拓展一个新身份。&lt;/p&gt;

&lt;p&gt;具体如何做，一部分取决于你自己的选择，一部分则取决于你身边的人。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-jtyEYul-d1PIfrrJBUqRg&quot;&gt;经济高速公路上，突然经过的鸭子&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;假设一条高速公路上，所有车都维持在 100 公里每小时的速度，稳定运行。&lt;/p&gt;

&lt;p&gt;忽然一只鸭子冲到路上，吓得司机拼命踩刹车，停了下来。后面的第二辆车也急刹车，后面一辆一辆车都急刹车，还好都没有追尾。之后，鸭子仓皇逃窜，离开高速公路。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://alt-tab-macos.netlify.app/&quot;&gt;https://alt-tab-macos.netlify.app&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现跟 Windows 窗口管理器一样的窗口切换，同时在窗口里显示该窗口的名字，如果一个 App 有多个窗口，那就全都展示出来&lt;/p&gt;

&lt;p&gt;相见恨晚呐！&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tomverbeure.github.io/2022/02/20/GDBWave-Post-Simulation-RISCV-SW-Debugging.html&quot;&gt;调试FPGA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tom Verbeure深入将GDB服务器与RISC-V CPU连接起来，使调试FPGA变得更容易。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://0xax.gitbooks.io/linux-insides/content&quot;&gt;关于Linux内核&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这本书是关于Linux内核及其内部的。它涵盖了Linux内核的工作原理和其他低级主题。主题包括启动、初始化、中断、系统调用、同步原语和内存管理。这本书仍在进行中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;过去一周&quot;&gt;过去一周&lt;/h1&gt;

&lt;p&gt;写了篇关于llvm和cuda 的基础知识，但是图床用的cdn，被禁用了，还没有推上去。&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;看书最重要的就是定好&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;固定的时间&lt;/code&gt;，比如每天早起20分钟，那这个时间就可以用阅读，可以做自己喜欢事情，就可以避免日后每天纠结到底啥时候读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;福格行为模型 - 100%&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最近买了一本 莫言的书 那些奇奇怪怪的故事&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;喜欢作家这种风趣幽默的风格，同时有可能幽默和风趣不是你这个人本身的特质，但一定是作者的劳动成果。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;技术相关的书，大部分是电子书，因为可以随时的show me code。&lt;/li&gt;
  &lt;li&gt;方法、理论类的书籍，一般会停下来思考，提出问题、或者沉淀为自己的知识。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/05/28/keep-health/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/05/28/keep-health/</guid>
        
        
      </item>
    
      <item>
        <title>38 - 小习惯</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;今天是520，我想是一个美好的日子，祝大家节日快乐~&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;p&gt;今天老婆大人的胆囊炎犯了，还在急诊室输液喃，我就趁这个时间更新一篇来自医院的 Newsletter， 今天的内容就将就看一些呀 ~&lt;/p&gt;

&lt;p&gt;最近看的技术书籍比较多，所以个人成长之类的书就比较少了。输入的知识少了也比较好，同时自己也有时间来消化这些信息。&lt;/p&gt;

&lt;h2 id=&quot;行为设计&quot;&gt;行为设计&lt;/h2&gt;

&lt;p&gt;你有什么小的行为、或者改变可以分享的么？&lt;/p&gt;

&lt;p&gt;家里有一个地方看上去有点脏，就随手打扫干净，这样就不用等到特别脏的时候再去打扫，同时也很难等到有这样的场景。&lt;/p&gt;

&lt;p&gt;最近看福格行为这本书的时候，发现有一个小改变，生活中有很多这样的小改变，小改变也许没那么吸引人，但它是一种可持续的成功。在人们想做出的大多数人生改变中，有时采取小行为也许会比大胆的行为更有效。&lt;/p&gt;

&lt;p&gt;还有一个小习惯，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;我就是每天坚持给手机充电，基本上365天不间断。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个就是行为设计的力量，让你拥有了极大的改变潜力。无论你追求的是大改变还是小改变，从小事做起都是一个绝佳选择。&lt;/p&gt;

&lt;p&gt;下面是找出生活中，有哪些可以做到的行为设计：
·　你是否有足够的时间？
·　你是否有足够的资金？
·　你是否有足够的体力？
·　这个行为是否需要许多创意或脑力？
·　这个行为符合你现在的日程吗？还是需要做出调整？&lt;/p&gt;

&lt;p&gt;入门步骤是一种心理柔术，一个很小的动作却能带来极大的影响，它所创造的冲力往往能推动你在阻力极小的情况下向前迈进，而其中的关键就是不要抬高门槛。每完成一个入门步骤就是一次成功。每一次成功，都能让你继续坚持，增加养成习惯的可能性。&lt;/p&gt;

&lt;p&gt;迈出第一步，无论多么微小，都能让大脑活跃起来。完成任务不仅有助于增强信心，而且能让完成完整行为的动机高涨。&lt;/p&gt;

&lt;p&gt;庆祝是一种特殊的技巧，既能为人们带来行为改变，也能让他们产生心理转变。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jasont.co/ennui/&quot;&gt;如何保持在工作中的激情&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者例举了4个技巧，生命是短暂的，有了这四个技巧，你就不必痛苦了。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tinylab.org/open-c-book/&quot;&gt;一本透视 C 语言开发过程的开源书籍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一本透视 C 语言开发过程的开源书籍，如果你在学习C，或者深入学习C，亦或是编译器、汇编等，比较底层的知识，这个电子书籍是不错的选择。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/&quot;&gt;CUDA 入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也是我最近学习cuda，看的一本基础的电子书，通过一个hello cuda来入门，简单易懂，适合新手。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;过去一周&quot;&gt;过去一周&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;更新了5篇学习文档，由于都比较基础，就不用贴链接了&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;看书最重要的就是定好&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;固定的时间&lt;/code&gt;，比如每天早起20分钟，那这个时间就可以用阅读，可以做自己喜欢事情，就可以避免日后每天纠结到底啥时候读。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;福格行为模型 - 60%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;符合自己的心灵的感受，就是最好的，这样也能做的更久。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;技术相关的书，大部分是电子书，因为可以随时的show me code。&lt;/li&gt;
  &lt;li&gt;方法、理论类的书籍，一般会停下来思考，提出问题、或者沉淀为自己的知识。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天是坚持周更分享：第 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;38/60&lt;/code&gt; 期。&lt;/p&gt;

</description>
        <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/05/21/small-behavior/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/05/21/small-behavior/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>LLVM 测试</title>
        <description>&lt;p&gt;LLVM 测试基础设施包含三大类测试: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;单元测试、回归测试和整个程序&lt;/code&gt;。单元测试和回归测试分别包含在 LLVM 存储在 LLVM/unittest 和 LLVM/test 之下，并且应该始终通过，一般情况作为checkin，即它们应该在每次提交之前运行。&lt;/p&gt;

&lt;p&gt;单元测试是使用 Google Test 和 Google Mock 编写的，位于 llvm/unittest 目录中。在一般情况下，单元测试用于针对支持库和其他通用数据结构，我们倾向于依赖回归测试来测试 IR 上的转换和分析。&lt;/p&gt;

&lt;p&gt;回归测试是测试 LLVM 特定特性或在 LLVM 中触发特定 bug 的小段代码。它们使用的语言取决于测试的 LLVM 部分。这些测试由 Lit 测试工具(LLVM 的一部分)驱动，位于 LLVM/test 目录中。&lt;/p&gt;

&lt;p&gt;通常，当在 LLVM 中发现 bug 时，应该编写一个回归测试，其中包含足够的代码来重现问题，并将该测试放置在这个目录的某个位置。例如，它可以是从实际应用程序或基准中提取的一小段 LLVM IR。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chasays/mdPicGo@master/uPic/mxmvRb.png&quot; alt=&quot;mxmvRb&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;快速入门&quot;&gt;快速入门&lt;/h2&gt;

&lt;p&gt;测试位于两个独立的存储库中。单元测试和回归测试位于主“ LLVM”目录下的 LLVM/unittest 和 LLVM/test 目录下，(因此您可以通过主 LLVM-project 免费获得这些测试)。在构建 LLVM 之后，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make check-all&lt;/code&gt; 运行单元测试和回归测试。&lt;/p&gt;

&lt;p&gt;测试套件模块包含更全面的测试，包括整个 C 和 C++ 程序。&lt;/p&gt;

&lt;h3 id=&quot;如何运行单元测试和回归测试&quot;&gt;如何运行单元测试和回归测试&lt;/h3&gt;

&lt;p&gt;要运行所有 LLVM 单元测试，请使用 check-LLVM-unit 目标:&lt;/p&gt;

&lt;p&gt;` make check-llvm-unit`&lt;/p&gt;

&lt;p&gt;要运行所有 LLVM 回归测试，请使用 check-LLVM 目标:&lt;/p&gt;

&lt;p&gt;` make check-llvm`&lt;/p&gt;

&lt;p&gt;为了获得合理的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;测试性能&lt;/code&gt;，在编译的时候，应该是-release模式下构建 LLVM-project，编译命令&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmake -DCMAKE_BUILD_TYPE=&quot;Release&quot; -DLLVM_ENABLE_ASSERTIONS=On&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果您已经构建了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clang&lt;/code&gt; ，那么您可以使用以下方法同时运行 LLVM 和 Clang 测试:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make check-all&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同时还可以给运行测试的用例传递参数， 请使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIT_ARGS&lt;/code&gt;  变量将所需的选项传递给 LIT。例如，您可以使用:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make check LIT_ARGS=&quot;-v --vg --vg-leak&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其他可以参考&lt;a href=&quot;https://llvm.org/docs/CommandGuide/lit.html&quot;&gt;lit的用法&lt;/a&gt;，比如单个ll文件或者整个目录。&lt;/p&gt;

&lt;h2 id=&quot;回归测试的架构&quot;&gt;回归测试的架构&lt;/h2&gt;

&lt;p&gt;LLVM 回归测试由 lit 驱动，位于 llvm/test 目录中。&lt;/p&gt;

&lt;p&gt;这个目录包含大量的小型测试，这些测试使用 LLVM 的各种特性，并确保不会发生回归。这个目录被分成几个子目录，每个子目录都关注 LLVM 的一个特定区域。&lt;/p&gt;

&lt;h3 id=&quot;如何编译一个新的测试用例&quot;&gt;如何编译一个新的测试用例&lt;/h3&gt;

&lt;p&gt;回归测试结构非常简单，但是需要设置一些信息。这些信息通过 cmake 收集并写入构建目录中的文件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test/lit.site.cfg&lt;/code&gt;。Llvm/test Makefile文件 为您完成这项工作。&lt;/p&gt;

&lt;p&gt;为了使回归测试工作，每个测试目录必须有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lit.local.cfg &lt;/code&gt;文件。Lit 查找此文件以确定如何运行测试。这个文件只是 Python 代码，因此非常灵活，但是我们已经为 LLVM 回归测试对它进行了标准化。如果要添加一个测试目录，只需从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;另一个目录复制 lit.local.cfg 即可&lt;/code&gt;。标准的 lit.local.cfg 只是指定要查找哪些文件以进行测试。任何只包含目录的目录都不需要 lit.local.cfg 文件。&lt;/p&gt;

&lt;p&gt;每个测试文件必须包含以“ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN:&lt;/code&gt;”开头的行，告诉 lit 如何运行它。如果没有 RUN 行，lit 将在运行测试时发出错误。&lt;/p&gt;

&lt;p&gt;同时还可以有多个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt;行。RUN 行在测试程序的注释中使用关键字 RUN 后跟冒号和要执行的命令(管道)来指定。这些行组成了 lit 执行以运行测试用例的“脚本”。RUN 行的语法类似于 shell 管道的语法，包括 I/O 重定向和变量替换。但是，即使这些行看起来像 shell 脚本，它们也不是。RUN 行由 lit 解释。因此，语法与 shell 在几个方面有所不同。您可以根据需要指定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;尽可能多的 RUN 行。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lit 对每个 RUN 行执行替换操作，以替换 LLVM 工具名，使用为每个工具构建的可执行文件的完整路径(在 $(LLVM_OBJ_ROOT)/$(BuildMode)/bin 中)。这样可以确保 lit 在测试期间不会调用用户路径中的任何其他 LLVM 工具。&lt;/p&gt;

&lt;p&gt;每个 RUN 行都是独立执行的，与其他行不同，除非它的最后一个字符是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;,和python的换行有点类似。这个延续字符将使 RUN 行与下一行连接起来。通过这种方式，您可以构建长长的命令管道，而不需要制造巨大的行长度。以该行结尾的行被连接起来，直到找到一个不以该行结尾的 RUN 行。然后，这组连接的 RUN 行构成一个执行。Lit 将替换变量并安排管道的执行。如果管道中的任何进程失败，则整个行(和测试用例)也会失败。&lt;/p&gt;

&lt;p&gt;下面是.ll 文件中合法的 RUN 行的示例:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; RUN: llvm-as &amp;lt; %s | llvm-dis &amp;gt; %t1
; RUN: llvm-dis &amp;lt; %s.bc-13 &amp;gt; %t2
; RUN: diff %t1 %t2

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试的时候，不会修改文件的内容信息，一般来说，您应该尽量保持您的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; RUN 行尽可能简单&lt;/code&gt;，只使用它们来运行生成文本输出的工具，然后您可以检查这些工具。检查输出以判断测试是否通过的推荐方法是使用 FileCheck 工具。[不推荐在 RUN 行中使用 grep-请不要发送或提交使用它的补丁程序。]&lt;/p&gt;

&lt;h3 id=&quot;自动生成断言&quot;&gt;自动生成断言&lt;/h3&gt;

&lt;p&gt;有些回归测试用例非常大，手工编写/更新非常复杂。在这种情况下，为了减少人工工作，我们可以使用 llvm/utils/中提供的脚本来生成断言。&lt;/p&gt;

&lt;p&gt;例如，要在基于 llc 的测试中生成断言，请运行:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/utils/update_llc_test_checks.py --llc-binary build/bin/llc test.ll&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;除了生成，还可以更新断言信息&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-u&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;以下是生成断言时最常见的脚本及其用途/应用程序:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update_analyze_test_checks.py
opt &lt;span class=&quot;nt&quot;&gt;-passes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'print&amp;lt;cost-model&amp;gt;'&lt;/span&gt;

update_cc_test_checks.py
C/C++, or clang/clang++ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;IR checks&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

update_llc_test_checks.py
llc &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;assembly checks&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

update_mca_test_checks.py
llvm-mca

update_mir_test_checks.py
llc &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MIR checks&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

update_test_checks.py
opt

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;高级用法&quot;&gt;高级用法&lt;/h3&gt;

&lt;p&gt;如果您的测试需要除了包含 RUN: 行的文件之外的其他文件，并且额外的文件很小，那么可以考虑在同一个文件中指定它们，并使用 split-file 来获取它们。比如说,&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; RUN: split-file %s %t
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; RUN: llvm-link &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; %t/a.ll %t/b.ll | FileCheck %s

&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; CHECK: ...

&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; a.ll
...
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; b.ll
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面分隔的用的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;--- a.ll&lt;/code&gt;，符合这个即可&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^(.|//)--- &amp;lt;part&amp;gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果您想要测试像 [[#@LINE+1]] 这样的相对行号，那么指定 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--leading-lines&lt;/code&gt; 以添加前导空行来保留行号。&lt;/p&gt;

&lt;p&gt;期望匹配和不期望匹配，&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;CHECK: xx 这个是期望匹配
；CHECK-NOT:期望不匹配
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了保持健壮性，始终在 RUN 行中使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx .. &amp;lt; %s&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;平台测试&quot;&gt;平台测试&lt;/h3&gt;

&lt;p&gt;比如有nvidia、adm、x86、metax等等，此外，如果测试依赖于在任何后端中编码的任何行为，那么它必须放在自己的目录中。&lt;/p&gt;

&lt;p&gt;因此，例如，ARM 的代码生成器测试进入 test/CodeGen/ARM 等。这些目录包含一个特殊的指定配置文件，确保该目录中的所有测试只有在特定的后端已编译并可用时才会运行。&lt;/p&gt;

&lt;p&gt;在 test/CodeGen/ARM 中，这个文件lit.local.cfg 是内容是:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config.suffixes = ['.ll', '.c', '.cpp', '.test']
if not 'MetaX' in config.root.targets:
  config.unsupported = True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;测试约束&quot;&gt;测试约束&lt;/h3&gt;

&lt;p&gt;有些测试只能在特定的配置中运行，例如使用调试构建或在特定的平台上运行。使用 REQUIRES 和 UNSUPPORTED 控制何时启用测试。&lt;/p&gt;

&lt;p&gt;比如：一些测试预计会失败。例如，测试可能检测到一个已知的 bug。使用 XFAIL 将测试标记为预期失败。如果执行失败，XFAIL 测试将成功; 如果执行成功，XFAIL 测试将失败。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; This test will be only enabled in the build with asserts.
; REQUIRES: asserts
; This test is disabled on Linux.
; UNSUPPORTED: -linux-
; This test is expected to fail on PowerPC.
; XFAIL: powerpc

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;REQUIRES、 UNSUPPORTED 和 XFAIL 都接受以逗号分隔的布尔表达式列表&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;REQUIRES 如果所有表达式都为 true，则启用测试&lt;/li&gt;
  &lt;li&gt;UNSUPPORTED 如果任何表达式都为 true，则禁用测试&lt;/li&gt;
  &lt;li&gt;XFAIL 如果任何表达式都为 true，则预期测试失败&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;还有检查点可以使用正则表达，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;CHECK: load heo&lt;/code&gt;, 期望匹配的是 load helo&lt;/td&gt;
      &lt;td&gt;hello&lt;/td&gt;
      &lt;td&gt;hellllo等。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;read-more&quot;&gt;Read more&lt;/h2&gt;

&lt;p&gt;https://www.youtube.com/watch?v=VFHYaH5Vr4I&amp;amp;ab_channel=LLVM&lt;/p&gt;

&lt;p&gt;https://llvm.org/docs/TestingGuide.html#extra-files&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/05/19/LLVM-GPU-Compiler/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/05/19/LLVM-GPU-Compiler/</guid>
        
        <category>cuda</category>
        
        
      </item>
    
      <item>
        <title>CUDA 入门教程</title>
        <description>&lt;p&gt;可以用 CUDA 创建大规模并行处理机应用程序的方法之一。它允许您使用强大的 c++ 编程语言来开发高性能算法，这些算法由运行在 GPU 上的数千个并行线程加速。&lt;/p&gt;

&lt;p&gt;许多开发人员已经通过这种方式加速了他们计算和带宽需求量巨大的应用程序，包括支持深度学习这一人工智能革命的库和框架。&lt;/p&gt;

&lt;p&gt;需要有NV显卡的电脑，环境准备，我用的thinkpad，装的windows，在wsl下面安装cuda，参考官方的文档：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin
&lt;span class=&quot;nb&quot;&gt;sudo mv &lt;/span&gt;cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600
wget https://developer.download.nvidia.com/compute/cuda/11.7.0/local_installers/cuda-repo-wsl-ubuntu-11-7-local_11.7.0-1_amd64.deb
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;dpkg &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; cuda-repo-wsl-ubuntu-11-7-local_11.7.0-1_amd64.deb
&lt;span class=&quot;nb&quot;&gt;sudo cp&lt;/span&gt; /var/cuda-repo-wsl-ubuntu-11-7-local/cuda-&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-keyring&lt;/span&gt;.gpg /usr/share/keyrings/
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get update
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;cuda
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面用c代码和cuda来比较下.&lt;/p&gt;

&lt;p&gt;C 代码&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;c_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CUDA 代码&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cuda_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World from GPU!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cuda_hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主要上面的 cuda代码里面，有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__global__&lt;/code&gt;，global指的是在GPU device侧运行， &lt;strong&gt;global&lt;/strong&gt; 函数就是kernel.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;device和host的区别：分别是GPU，一个是CPU.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要在 GPU 上计算，需要分配 GPU 可访问的内存。CUDA 中的统一内存通过提供一个单一的内存空间容易访问所有的 gpu 和 cpu 。要在统一内存中分配数据，请调用 cudaMallocManaged() ，它返回一个指针，可以通过主机(CPU)代码或设备(GPU)代码访问该指针。&lt;/p&gt;

&lt;p&gt;要释放数据，只需传递指针到 cudaFree()。&lt;/p&gt;

&lt;p&gt;再回到上面的代码中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cuda_hello&amp;lt;&amp;lt;&amp;lt;1,1&amp;gt;&amp;gt;&amp;gt;(); &lt;/code&gt;，这里的«&amp;lt;»&amp;gt;这个是特殊语法，cuda_hello是kernel函数，里面有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1,1&lt;/code&gt;，第一个1的含义是：block的数量， 一群这样的block称为grid（网格），并行的线程集合称为block.&lt;/p&gt;

&lt;p&gt;上面的第一个和第二个分别可以，像下面这么定义：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBlocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cuda_hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numBlocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CUDA gpu 有许多并行处理器组成流多处理器，或者SM（shared memeory）。每个 SM 可以运行多个并发线程块。例如，一个基于 Pascal GPU 架构的 Tesla P100 GPU 有56 SM，每SM最多可支持2048个活动线程。为了充分利用所有这些线程，我应该启动带有多个线程块的内核。&lt;/p&gt;

&lt;p&gt;第二个1的意思是多少个线程，这个数是32的倍数，在cuda里面，可以用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockDim.x&lt;/code&gt;获取线程的数量，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;threadIdx.x&lt;/code&gt;这个获取当前线程的index.
cuda 还提供了用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockIdx.x&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gridDim.x&lt;/code&gt;,分别获取block的index和块的数量.&lt;/p&gt;

&lt;p&gt;所以就可以通过上面内置的函数获取偏移量&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockDim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockDim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gridDim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stride&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;比如下面就是求第三个黄色区域值的index.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/20220519193219.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;分配主机内存和初始化的主机数据&lt;/li&gt;
  &lt;li&gt;分配设备内存&lt;/li&gt;
  &lt;li&gt;将输入数据从主机传输到设备存储器&lt;/li&gt;
  &lt;li&gt;执行内核&lt;/li&gt;
  &lt;li&gt;将输出从设备存储器传输到主机&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果没有NVIDIA的显卡，下一个介绍下如何使用google colab提供的免费GPU来测试下。&lt;/p&gt;

&lt;h2 id=&quot;read-more&quot;&gt;Read more&lt;/h2&gt;

&lt;p&gt;https://www.nvidia.com/docs/IO/116711/sc11-cuda-c-basics.pdf&lt;/p&gt;

&lt;p&gt;https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/&lt;/p&gt;

&lt;p&gt;https://developer.nvidia.com/blog/even-easier-introduction-cuda/&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2022/05/19/CUDA-beginner-guider/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2022/05/19/CUDA-beginner-guider/</guid>
        
        <category>cuda</category>
        
        
      </item>
    
  </channel>
</rss>
