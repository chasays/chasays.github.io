<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>察说花园</title>
    <description>人生就是干</description>
    <link>https://blog.chiphub.top/</link>
    <atom:link href="https://blog.chiphub.top/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 30 Mar 2023 02:33:07 +0000</pubDate>
    <lastBuildDate>Thu, 30 Mar 2023 02:33:07 +0000</lastBuildDate>
    <generator>Jekyll v3.9.3</generator>
    
      <item>
        <title>如何调试我们 LLVM 的代码 - 进阶</title>
        <description>&lt;p&gt;前面简单介绍了如何从一个bc文件里面提炼出一个精简的ll文件，只包含报错的函数。&lt;/p&gt;

&lt;p&gt;如果看到的不正确的行为是由于一个优化pass，一个非常方便的LLVM选项是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-opt-bisect-limit&lt;/code&gt;，它采用一个整数表示要运行的最高pass的索引值。所取pass的索引值在不同的运行中是稳定的；通过将其与根据结果程序自动划分搜索空间的软件相结合，可以快速确定错误的通道。当指定了-opt-bisect-limit时，所有的运行都会被显示到标准错误中，同时显示它们的索引和输出，表明是否运行或跳过了该通道。将限制设置为索引-1（例如，RUSTFLAGS=”-C llvm-args=-opt-bisect-limit=-1”）将显示所有的通过和它们相应的索引值。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/30/how-to-debug-llvm-code-2/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/30/how-to-debug-llvm-code-2/</guid>
        
        <category>compiler</category>
        
        <category>LLVM</category>
        
        <category>debug</category>
        
        
      </item>
    
      <item>
        <title>82 -  知行合一</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多听听播客、多出去走走，旅游，会带给你不同领域的知识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;「生财有术」一个谈钱不伤感情的社群，目前的 418 会员日来了，我有2点建议。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;利用信息差赚钱，等到大众知道这个消息的时候，这个行业就是红海， 不是蓝海了，就很少有机会来赚钱了&lt;/li&gt;
  &lt;li&gt;执行力，这个是钞能力路上不可获取的一个能力；也是大部分人缺少这个能力的。如果你的执行力不强，我还是劝退你，毕竟现在的肉价才20+，接近2000的会员费。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你和我一样，不是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;知行合一&lt;/code&gt;的人，我个人建议你没必要加入，毕竟年会费接近2000，菜场100块都可以买好多菜喃。&lt;/p&gt;

&lt;h2 id=&quot;站在对方的角度思考&quot;&gt;站在对方的角度思考&lt;/h2&gt;

&lt;p&gt;打羽毛球，你想接什么球？高远球，不急不快的，不重的，让你有时间调整步伐和姿势。&lt;/p&gt;

&lt;p&gt;那反过来你不想接什么球？低平球，快速的，重的，让你难以抵挡和还击。对方也不想接这样的球，所以你要尽量发出这样的球，给对方制造压力和困难。&lt;/p&gt;

&lt;p&gt;对于竞技类、对抗类游戏，比如电子游戏、篮球、拳击，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;做对方害怕或者是不想做的事情&lt;/code&gt;，结果不会太差。&lt;/p&gt;

&lt;h2 id=&quot;玩德州扑克&quot;&gt;玩德州扑克&lt;/h2&gt;

&lt;p&gt;我估计不少人应该玩过扑克里面的「炸金花」。&lt;/p&gt;

&lt;p&gt;最近我开始玩上了德州扑克，可比四川炸金花更有趣，不仅是一种全球性的扑克游戏，还荟萃了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;金融、概率、心理博弈等多方面的元素&lt;/code&gt;，每年的大大小小比赛。&lt;/p&gt;

&lt;p&gt;最近我在德州扑克里面，体验了 2 种乐趣：平衡感和过程体验。&lt;/p&gt;

&lt;p&gt;保持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;平衡感是德州扑克&lt;/code&gt;中非常重要的一点，它不论是什么牌都需要保持平衡，不然很容易被对手发现缺陷，甚至会被对手构成炸弹局面。只有保持平衡感，玩家才能在游戏中更好的进行策略性的思考和判断，炸金花也有类似的体验。&lt;/p&gt;

&lt;p&gt;但是又与炸金花不同，德州扑克不是一个单纯为了奖金而存在的游戏，玩家更是享受其中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;过程体验&lt;/code&gt;。在游戏中每一个过程都需要刻意&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;选择纪律性，掌握机会与风险&lt;/code&gt;，才能在整场比赛中获得胜利。这种过程体验能够带给玩家非常深刻的提升，让他们在游戏中享受每个过程带来的乐趣和收获。&lt;/p&gt;

&lt;p&gt;相对于彩票中奖的概率较低，德州扑克显然存在着较高的ev和获胜概率。到达游戏中的每一个环节，玩家们的技巧和运气会影响其获胜概率和收益，只有做好准备和规划，才能收获出色的结果。因此，德州扑克是一种非常刺激的游戏，让玩家们敢于追求胜利与乐趣并存的感觉。&lt;/p&gt;

&lt;p&gt;说到正ev，那就有负ev。比如彩票中奖概率很低，最后一等奖只有奖池的70%，这个就是很明显的负ev。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么是负 expect value？ 是指一个行动或策略在长期下来会带来的平均损失。它是所有可能的结果乘以其结果概率的总和的负数。例如，如果你掷一枚公平的六面筛子，每次掷出的点数就是你赢得的钱数，但是每次掷之前你要付出4元，那么你的 expect value 是：&lt;/p&gt;

  &lt;p&gt;(1/6)×1 + (1/6)×2 + (1/6)×3 + (1/6)×4 + (1/6)×5 + (1/6)×6 - 4 = -0.5&lt;/p&gt;

  &lt;p&gt;这意味着你每次玩这个游戏，平均会亏损0.5元，所以这是一个负 expect value 的游戏。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/AW_z1fVecX1Mq7PGBoLiyQ&quot;&gt;瑞信，死不足惜&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;强买强卖的说法并不夸张，因为瑞信在纽约和苏黎世两地上市，瑞信的股东们对这次收购应该有投票权的，但瑞士政府单方面耍横——必须卖&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iFtlqgDrtknfAq7iNQpzAw&quot;&gt;AI art 实验：同样的Prompt, DALLE2 跟 Disco Diffusion 的创作大比拼&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者对比2种图片生成模型的结果，已经不同情况下，那种更好一点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fatsoftwareengineer.substack.com/p/building-a-second-income-stream-by&quot;&gt;通过写书建立第二收入来源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230323085914.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作者分享了他如何通过写一本技术书籍来建立一个第二收入流的经历。他讲述了以下几个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;他是如何被一家知名的技术书籍出版商联系的，以及他为什么同意接受这个挑战。&lt;/li&gt;
  &lt;li&gt;写一本书的过程是怎样的，包括写作计划、编辑反馈、合同条款、版权问题等。&lt;/li&gt;
  &lt;li&gt;他目前从书籍中赚了多少钱，以及他对未来的收入预期是什么。&lt;/li&gt;
  &lt;li&gt;他是否会再次写书，以及他对想要写书的人的一些建议。&lt;/li&gt;
  &lt;li&gt;作者认为写一本书是一种非常困难和耗时的方式来建立一个被动收入流，但也是一种有价值和有成就感的方式。他强 - 调了保持质量和专业性的重要性，以及在写作过程中保持动力和耐心的必要性&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/paulocoutinhox/pdfium-lib&quot;&gt;pdfium-lib&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://xiaobot.net/p/shengcaiyoushu?&quot;&gt;生财有术项目精选&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个付费的类容，如果你是一个知行合一，搞钱特别行，那可以看看里面的赚钱路子。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://streamlit.io/&quot;&gt;Streamlight&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过应用程序构建和共享数据的更快方式
Streamlight 在几分钟内就能将数据脚本变成可共享的网络应用程序。
所有这些都是在一个纯Python中实现的，不需要任何前端经验。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/m8hiQo6smRnHFjPkGfYLNQ&quot;&gt;关于GPT答朋友问&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在另外一边，AI也好，GPT也罢，未来算力提升会让智能提升到什么人类无法想象和企及的境界我不清楚，起码在现在，它们没可能超脱于现实世界而独立存在。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://codeium.com/&quot;&gt;codeium 类似github copilot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;codeium 类似github copilot，支持各种IDE的插件，对于个人用户来说，目前是永久免费。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/antimatter15/alpaca.cpp&quot;&gt;alpaca.cpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在你的设备上本地运行类似于ChatGPT的快速模型。意思就是可以在普通的笔记本上运行这个模型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.duolingo.com/duolingo-max/&quot;&gt;duolingo-max&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Duolingo 推出了新的订阅层次 Duolingo Max，提供两项新的基于人工智能技术的功能：Explain My Answer 和 Roleplay。这些功能可以让学习者了解自己的答案并练习与 AI 生成的角色进行真实对话。Duolingo 与 OpenAI 密切合作数月来完善技术，并确保准确性。人类评估内容并审查由 AI 生成的解释以确保事实正确和适当的语气。这些新功能仅在 iOS 上的面向英语使用者的西班牙语和法语课程上可用，在部分国家上线，计划很快扩展。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/25/Forward-Position/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/25/Forward-Position/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>如何调试我们 LLVM 的代码 - 入门</title>
        <description>&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;

&lt;p&gt;LLVM是一个独立的大项目，可能需要有自己的调试文档，我似乎没有找到这样的文档，估计做LLVM都是的大佬或者是骨灰级的人物，不需要文档吧，注释就在代码中。&lt;/p&gt;

&lt;p&gt;比如在开发一个llvm的pass，或者一个feature，在编译的过程中crash了， 怎么去定位和修复的喃？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230317094622.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意官方编译器禁用了LLVM断言，这意味着LLVM断言失败可能会显示为编译器崩溃（不是ICE-内部编译错误，而是 “真正的”崩溃）和其他各种奇怪的行为。编译llvm的时候最好使能assertion，在cmake的时候记得带上参数即可：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assertions=true&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;尽量最小化例子&quot;&gt;尽量最小化例子&lt;/h2&gt;

&lt;p&gt;一般来说，编译器从分析代码中产生大量的信息。因此，一个有用的第一步通常是找到一个最小的例子。做到这一点的一个方法是&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个重现该问题的新case（例如，将有问题的地方添加为依赖关系，并从这里开始）&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;移除外部依赖关系&lt;/code&gt;来最小化这个板块；也就是说，将所有相关的东西移到新文件中去&lt;/li&gt;
  &lt;li&gt;通过缩短代码来进一步减少问题（有一些工具可以帮助实现这一点，比如creduce）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际的工程中，是通过如下步骤，不过工程有一点差异，但是可以参考这个过程：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用编译器（gcc/clang,或者其他）编译cpp文件为一个ll文件&lt;/li&gt;
  &lt;li&gt;通过上面生成的 ll 文件，从中提取报错函数的最小 ll文件&lt;/li&gt;
  &lt;li&gt;然后带上mtriple，map，mcpu等参数用llc来编译这个 ll 文件为汇编，一般在这个时候就会出问题了。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 编译cpp为一个ll文件&lt;/span&gt;
clang &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-emit-llvm&lt;/span&gt; test.cpp

&lt;span class=&quot;c&quot;&gt;# 提取文件里面的该funtion有关的ir&lt;/span&gt;
llvm-ir-extractor test.ll &lt;span class=&quot;nt&quot;&gt;--save-mode&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;functioName&quot;&lt;/span&gt; &amp;amp;&amp;gt; new.ll

&lt;span class=&quot;c&quot;&gt;# 用llc来编译&lt;/span&gt;
llc &lt;span class=&quot;nt&quot;&gt;-mtriple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;amdgpucn &lt;span class=&quot;nt&quot;&gt;-verify&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;machineinstrs new.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;获得一个原始的输入文件&quot;&gt;获得一个原始的输入文件&lt;/h2&gt;

&lt;p&gt;大致情况是把一个crash文件，一个bc文件转化为一个ll文件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果在调用LLVM时遇到了来自 LLVM 后台的断言失败或分段故障，不妨尝试将这些 .bc 文件分别传递给 llc 命令，看看是否得到了同样的失败。(LLVM的开发者通常更喜欢被简化为.bc文件的bug，而不是使用工具最小化再来复现)。&lt;/li&gt;
  &lt;li&gt;为了得到人类可读的LLVM bc文件，人们只需要使用llvm-dis将位码（.bc）文件转换为.ll文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果只想在LLVM pipeline中获得LLVM的IR，例如查看哪个IR导致优化时间断言失败，或者查看LLVM何时执行特定的优化，可以通过llvm标志位&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-print-after-all&lt;/code&gt;，这样就可以获得更多的报错信息，从而精准找到问题所在。&lt;/p&gt;

&lt;p&gt;这将产生大量的输出到标准错误中，所以要把这些输出管到某个文件中。另外，如果既没有使用-filter-print-funcs，也没有使用-C codegen-units=1，那么，由于多个codegen单元并行运行，打印结果会混在一起，会有很多的无效信息，将无法阅读任何东西，或者很难找到问题所在。&lt;/p&gt;

&lt;p&gt;如果是单个函数在一个ll文件或者是bc文件里面，这样用这个方法是好处理，但是有多个函数，估计就不好处理了，还可以继续精简么？&lt;/p&gt;

&lt;p&gt;精简到只有这个对应函数和其依赖，这样就好定位处理了，同时也能把这个case加入到日常的看护中。&lt;/p&gt;

&lt;p&gt;可以用到2个工具，一个是llvm-extract/llvm-ir-extractor。&lt;/p&gt;

&lt;p&gt;先说说第一个的用法，还是举个例子吧。&lt;/p&gt;

&lt;p&gt;准备一个ir文件，在x86的机器上运行，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ll&quot;&gt;declare {i32, i1} @llvm.sadd.with.overflow.i32(i32, i32)
declare {i32, i1} @llvm.uadd.with.overflow.i32(i32, i32)

; The immediate can be encoded in a smaller way if the
; instruction is a sub instead of an add.
define i32 @test1(i32 inreg %a) nounwind {
entry:
  %b = add i32 %a, 128
  ret i32 %b
}

define i32 @test1b(i32* %p) nounwind {
entry:
  %a = load i32, i32* %p
  %b = add i32 %a, 128
  ret i32 %b
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个ir文件里面，包含了2个函数，分别为test1和test1b，现在需要把test1函数提出来，只需要这个函数。的ll文件。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llvm-extract &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'test_add'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &amp;lt; add.ll &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; extracted.ll

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行上面命令后，查看 extracted.ll，这个文件里面的内容如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ll&quot;&gt;; ModuleID = '&amp;lt;stdin&amp;gt;'
source_filename = &quot;&amp;lt;stdin&amp;gt;&quot;

; Function Attrs: nounwind
define i32 @test1(i32 inreg %a) #0 {
entry:
  %b = add i32 %a, 128
  ret i32 %b
}

attributes #0 = { nounwind }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是简单了。今天就先来一个简单的，后面继续学习下一个关于优化pass的调试和定位。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://rustc-dev-guide.rust-lang.org/backend/debugging.html#enable-llvm-internal-checks&quot;&gt;Rust Compiler Development Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/&quot;&gt;rust 最小化代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/18/how-to-debug-llvm-code/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/18/how-to-debug-llvm-code/</guid>
        
        <category>compiler</category>
        
        <category>LLVM</category>
        
        <category>debug</category>
        
        
      </item>
    
      <item>
        <title>81 -  GPT4 来了</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;如果有一天你发现自己被一台电脑取代了怎么办？别担心，这不是科幻小说里的情节，而是可能很快就会发生在我们身边的现实。因为 GPT4 已经出现了！&lt;/p&gt;

&lt;p&gt;GPT4  是什么？简单地说，它就是一个能写出任何东西的超级机器人。不管你想要什么样子、什么风格、什么内容、什么语言、什么格式、什么长度、甚至什么字体都可以满足你。&lt;/p&gt;

&lt;p&gt;听起来很神奇吧？但是也很可怕！因为它不光能写出东西，还能写得比我们更好！&lt;/p&gt;

&lt;p&gt;GPT4 的出现，让许多人感到焦虑不安，其中最重要的两个问题是：是否能赚到钱和是否会被取代或失业。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230317085036.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于第一个问题，历史规律表明，只有少部分人能够从这种类型的技术中赚到钱。此类人主要是利用信息差贩卖信息的，他们可能会从中获得可观的收入。现在像知识星球和小报童这些已经开始推出各种课程，每天都有很多人报名，并且在短时间内得到了非常好的回报。&lt;/p&gt;

&lt;p&gt;虽然对于我们这些普通人而言，赚钱的机会可能较少，但可以通过学习一些 prompt 和提示词，并将其应用于日常生活中，例如当我作为一个程序员遇到困难时，通常我更倾向于在网上使用 Google 或 Stack   Overflow 查询。这些答案有可能很难找到，但你可以快速地将你的问题描述给 ChatGPT ，并很快地找到解决办法，我身边有很多人遇到问题都喜欢通过询问 ChatGPT 来解决，这种方法比自己去找答案更快更省时。&lt;/p&gt;

&lt;p&gt;对于第二个问题，我们可以考虑到一些容易被替代的工作，例如文字编辑和 PPT 的简单制作等没有技术门槛的工作，在 ChatGPT   Plus 的 API 接口上，每个月只需花费 200 块，就能找到一个替代人员，难道你会雇一个人只给他/她 100 块吗？这是不现实的，因此这些替代工作可能会被取代。&lt;/p&gt;

&lt;p&gt;目前已经有些公司开始使用 Midjourney   v5 来生成一些图像，例如制作定制化的图片等，这是一项非常有新意的技术，能够生成非常逼真的图像，甚至超越人类能力，完全看不出是由 AI 生成的。&lt;/p&gt;

&lt;p&gt;但是，这些技术是否会为我们带来收益还存在一定的疑虑，例如生成一首歌曲，但如果这首歌曲并没有广受欢迎或者没有被商用，则可能只是娱乐而已，无法为我们带来实际的价值。因此，我们应该是以结果为导向，将这些技术应用于实际领域中，使之与商业结合起来，这样才能发挥其真正的潜力，而不仅仅停留在娱乐的层面上。&lt;/p&gt;

&lt;p&gt;总的来说， GPT4 的出现无疑为我们带来了很多便利和创造机会，但我们也应该意识到，如何将这些技术应用于实际问题上，创造出更多有价值的产品和服务，才是这项技术发展的关键所在。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份 Newsletter ，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wallstreetcn.com/articles/3684246&quot;&gt;微软深夜放炸弹！GPT-4 Office全家桶发布，10亿打工人被革命&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;微软宣布Microsoft 365 Copilot，将在未来几个月内把OpenAI的GPT-4带到Excel、PowerPoint、Outlook、Word及其他Office应用中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.bloomberg.com/news/articles/2023-03-16/chip-globalization-is-over-and-sanctions-work-says-tsmc-founder&quot;&gt;台积电创始人说：芯片全球化已经结束，制裁起作用了&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://yesaiwen.com/art-of-asking-chatgpt-for-high-quality-answ-engineering-techniques/?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=61310502961152&quot;&gt;如何向ChatGPT提问并获得高质量的答案&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;非常高兴您阅读我的新书《如何向ChatGPT提问并获得高质量的答案——提示技术的完整指南》。&lt;/p&gt;

&lt;p&gt;本书是一本综合性的指南，目的是帮助您理解和利用各种提示技术，以便从ChatGPT中获得高质量的答案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogs.bing.com/search/march_2023/Confirmed-the-new-Bing-runs-on-OpenAI%E2%80%99s-GPT-4&quot;&gt;证实：新必应在OpenAI的GPT-4上运行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过需要全程科学上网。&lt;/p&gt;

&lt;p&gt;新的Bing是在GPT-4上运行的，MS 为搜索进行了定制。如果你在过去五周的任何时候使用过新必应预览版，你已经体验到了这个强大模型的早期版本。随着OpenAI对GPT-4及以后的更新，Bing将从这些改进中受益。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pytorch.org/blog/pytorch-2.0-release/&quot;&gt;pytroch 2.0 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PyTorch 2.0提供了相同的急切模式开发和用户体验，同时从根本上改变和提高了PyTorch在编译器层面的运行方式，提高了性能并支持动态形状和分布式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/m8hiQo6smRnHFjPkGfYLNQ&quot;&gt;关于GPT答朋友问&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在另外一边，AI也好，GPT也罢，未来算力提升会让智能提升到什么人类无法想象和企及的境界我不清楚，起码在现在，它们没可能超脱于现实世界而独立存在。&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/18/GPT4-release/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/18/GPT4-release/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>如何通过chatgpt，获取高质量的回答</title>
        <description>&lt;h1 id=&quot;开篇&quot;&gt;开篇&lt;/h1&gt;

&lt;p&gt;任务：对模型生成内容的清晰、简洁的陈述。&lt;/p&gt;

&lt;p&gt;说明：模型生成文本时应遵循的指令。&lt;/p&gt;

&lt;p&gt;角色：模型在生成文本时应承担的角色。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://yesaiwen.com/art-of-asking-chatgpt-for-high-quality-answ-engineering-techniques/?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=61310502961152&quot;&gt;《如何向ChatGPT提问并获得高质量的答案》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/17/chatgpt-promt-words/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/17/chatgpt-promt-words/</guid>
        
        <category>chatgpt</category>
        
        <category>promt</category>
        
        
      </item>
    
      <item>
        <title>编译器优化 3 - 常量折叠和传播</title>
        <description>&lt;p&gt;前面了解了lto、thinlto、以及inline优化、死代码优化等。今天继续学习下常量折叠优化，&lt;/p&gt;

&lt;h2 id=&quot;常量折叠和常量传播&quot;&gt;常量折叠和常量传播&lt;/h2&gt;

&lt;p&gt;常量折叠和常量传播有什么不同？它们似乎都做了同样的事情，而不是将常量保存到堆栈中或计算完整的算术表达式，而是简单地将其替换为可以在编译时获得的结果。两者之间有什么不同？&lt;/p&gt;

&lt;p&gt;区别在于，常量传播&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不是将一个变量保存到堆栈中&lt;/code&gt;，因为我们知道它是一个常量，可以简单地将它插入到任何地方，它被用于机器代码中。而常数折叠是简单地评估，使用常数的表达式，并将结果代入机器码。&lt;/p&gt;

&lt;p&gt;来吧，看一个例子&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 常量传播&lt;/span&gt;
x &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 10
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x + x + x
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 10 + 10 + 10

&lt;span class=&quot;c&quot;&gt;# 常量折叠&lt;/span&gt;
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 10 + 10 + 10
y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这就是区别。常量传播只是用绑定的常量表达式&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;替换绑定的变量&lt;/code&gt;，而常量折叠则&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;是评估一个（无副作用的）表达式&lt;/code&gt;，其中所有输入都是编译时常量。&lt;/p&gt;

&lt;p&gt;常量传播是一种编译器优化方法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;，它可以在编译期间用常量值替换变量或表达式，从而减少运行时的计算开销和代码大小&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;常量传播有四种算法：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;简单常量传播、稀疏简单常量传播、条件常量传播和稀疏条件常量传播&lt;/code&gt;，它们的效率和精度各有不同。&lt;/p&gt;

&lt;p&gt;常量折叠是一种与常量传播相关的优化方法，它可以将具有已知常量值的运算符表达式简化为操作数。&lt;/p&gt;

&lt;h2 id=&quot;常量折叠&quot;&gt;常量折叠&lt;/h2&gt;

&lt;p&gt;常量折叠是指在编译时识别和评估常量表达式的过程，而不是在运行时计算它们。常量表达式中的术语通常是简单的字面意义，例如整数字面意义2，但它们也可能是变量，其值在编译时已经知道。考虑一下这个语句。&lt;/p&gt;

&lt;p&gt;比如： i = 20* 20 * 10;&lt;/p&gt;

&lt;p&gt;上面这个表达式，有2个乘号，很少有编译器的指令会对2个乘号做运算，并存到一个寄存器，比如我下才一个：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mul_mul dst,src0,src1,src2&lt;/code&gt;,想这样的指令看起来就比较怪异。所以在编译的时候替换计算值为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;常量折叠可以利用算术特性。如果x是数字，即使编译器不知道x的值，0*x的值也是零。&lt;/p&gt;

&lt;p&gt;注意，大部分编译器对 IEEE754 浮点数是无效的，因为x可能是Infinity或NaN。不过，为了性能，某些编译器允许对常数这样做。&lt;/p&gt;

&lt;p&gt;常数折叠可能不仅仅适用于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;数字。字符串和常量字符串&lt;/code&gt;的拼接可以被常量折叠。像 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;abc&quot;+&quot;def&quot;&lt;/code&gt;这样的代码可以被替换为 “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abcdef&lt;/code&gt;“。&lt;/p&gt;

&lt;h2 id=&quot;常量传播&quot;&gt;常量传播&lt;/h2&gt;

&lt;p&gt;常数折叠和传播通常一起使用，以实现许多简化和减少，通过迭代交织，直到不再发生变化。所以继续来看看常量传播。&lt;/p&gt;

&lt;p&gt;常数传播是在编译时将已知常数的值替换到表达式中的过程。这些常量包括上面定义的常量，以及应用于常量值的内在函数。考虑一下下面的伪代码。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;把 x （传播propagate）带入后，变成&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;继续传播，带入后的结果为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;组合起来使用&quot;&gt;组合起来使用&lt;/h2&gt;

&lt;p&gt;举个维基百科例子，从至少需要3个寄存器和7条基础指令（别问，瞎猜的，具体数量还要取决于硬件的设计），一个分支，优化到只有一个寄存器的过程：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用一次常量的传播，然后是常量的折叠，得到&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//折叠+传播&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 折叠&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再重复2次：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 传播+折叠&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 传播+折叠&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于a和b已经被简化为常数，并且它们的值在它们出现的地方都被替换了，编译器现在应用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;死代码消除法&lt;/code&gt;来丢弃它们，进一步减少了代码。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们肉眼就能看出来，if 这个分支里面始终都会别执行，难道编译器不行？别急，继续优化。&lt;/p&gt;

&lt;p&gt;在上面的代码中，根据编译器框架，它可以是1或任何其他布尔结构，而不是true。通过传统的常数传播，我们只能得到这么多的优化。它不能改变程序的结构。&lt;/p&gt;

&lt;p&gt;还有一个类似的优化，叫做稀疏条件常量传播，它根据if条件选择适当的分支，编译器现在可以检测到if语句总是评估为真，c本身可以被消除，进一步缩小代码。&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个伪代码构成了一个函数的主体，编译器可以进一步利用它评估为常数整数4的知识来消除对函数的不必要的调用，从而产生进一步的性能提升。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;常数传播是在编译器中使用到达定义分析结果实现的。如果所有变量的达成定义都是相同的赋值，而这个赋值又给变量分配了一个相同的常数，那么这个变量就有一个常数值，可以用这个常数来代替。&lt;/p&gt;

&lt;p&gt;常数传播也可以使条件分支简化为一个或多个无条件语句，此时条件表达式可以在编译时被评估为真或假，以确定唯一可能的结果。&lt;/p&gt;

&lt;p&gt;顺便推荐一个编译器优化方案的一个集合，还提供了一些测试集，对于编译器开发的同事来说，太棒了。我要推荐给你，知行合一，来卷起来。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;看名字就知道是什么： http://compileroptimizations.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ps.最近有个尴尬的烦恼，打「什么」2个字的时候，总是出现「SM」……
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/xB9W7B.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://compileroptimizations.com/category/constant_folding.htm&quot;&gt;Constant Folding&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;Constant Folding&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://oi-wiki.org/lang/optimizations/&quot;&gt;编译优化&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36287943/article/details/104974597&quot;&gt;编译优化之 - 常量传播入门&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/15/compiler-const-folding/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/15/compiler-const-folding/</guid>
        
        <category>gcc</category>
        
        <category>compiler</category>
        
        <category>constant</category>
        
        <category>optimization</category>
        
        
      </item>
    
      <item>
        <title>编译器优化 2 - ThinLTO</title>
        <description>&lt;h2 id=&quot;什么是编译器优化&quot;&gt;什么是编译器优化&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;保持语义不变的情况下，对程序运行速度、程序可执行文件大小作出改进&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;编译器优化（Compiler optimization）是指在编译器将源代码转化为可执行代码的过程中，通过对程序的分析和优化，使得生成的目标代码在执行速度、占用内存等方面都能够达到更好的效果。&lt;/p&gt;

&lt;p&gt;具体来说，编译器优化可以通过减少代码的重复计算、减少缓存未命中的情况以及减少不必要的寄存器使用等方式提高程序的执行效率，从而让程序的运行更快、更稳定。同时，优化也可以使得编译出来的目标代码更加紧凑，减少程序所占用的内存和磁盘空间。&lt;/p&gt;

&lt;p&gt;编译器优化的主要目标是提高程序的性能、优化目标代码的大小以及减少程序的资源占用。为了达到这些目标，编译器需要对源代码进行细致的分析，确定不必要的代码并去除，同时在编译过程中根据程序的表现不断进行优化调整，以逐步提高程序的性能。&lt;/p&gt;

&lt;p&gt;我们老大叫我们多看看在LLVM上优化，可以参考下GCC的优化方法。你们有没有什么好的方法？&lt;/p&gt;

&lt;h2 id=&quot;lto&quot;&gt;LTO&lt;/h2&gt;

&lt;p&gt;LTO（Link Time Optimization）是一种通过整个程序分析和跨模块优化来实现更好的运行时性能的方法。在编译阶段，clang会发出LLVM位码而不是对象文件。链接器会识别这些位码文件，并在链接过程中调用LLVM，以生成构成可执行文件的最终对象。LLVM实现加载所有输入的比特码文件，并将它们合并在一起以产生一个单一的模块。程序间分析（IPA）和程序间优化（IPO）在这个单体模块上连续进行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230313170728.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LTO有个缺点：这在实践中意味着LTO经常需要大量的内存（以一次容纳所有的IR），而且速度非常慢。而在通过-g启用调试信息的情况下，IR的大小和由此产生的内存需求会明显增大。即使没有调试信息，这对于非常大的应用程序，或者在内存受限的机器上进行编译，也是令人望而却步的。这也使得增量构建不那么有效，因为当任何输入源发生变化时，从LTO步骤开始的一切都必须重新执行。&lt;/p&gt;

&lt;h2 id=&quot;thinlto&quot;&gt;ThinLTO&lt;/h2&gt;

&lt;p&gt;ThinLTO 是一种新的方法，旨在像非LTO构建那样进行扩展，同时保留了全LTO的大部分性能成就。
在ThinLTO中，串行步骤是非常薄和快速的。这是因为它不是加载比特码和合并一个单一的单体模块来进行这些分析，而是利用每个模块的紧凑摘要来进行串行链接步骤中的全局分析，以及为后来的跨模块导入的函数位置索引。当模块在完全并行的后端进行优化时，函数导入和其他IPO转换将在以后进行。&lt;/p&gt;

&lt;p&gt;由ThinLTO全局分析实现的关键转换是函数导入，其中只有那些可能被内联的函数被导入到每个模块。这最大限度地减少了每个ThinLTO后端的内存开销，同时最大化了最有影响的跨模块优化机会。因此，IPO转换是在每个模块上用其导入的函数进行扩展。
ThinLTO的过程分为3个阶段。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;编译：与完全的LTO模式一样生成IR，但用模块摘要进行扩展。&lt;/li&gt;
  &lt;li&gt;thin link:thin 链接器插件层，结合摘要并进行全局分析&lt;/li&gt;
  &lt;li&gt;ThinLTO后端: 具有基于摘要的导入和优化的并行后端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230313171121.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个过程的关键因素是在第一阶段发出的摘要。这些摘要是使用比特码格式发布的，但设计成可以单独加载，而不涉及LLVMContext或任何其他昂贵的结构。每个全局变量和函数在模块摘要中都有一个条目。一个条目包含元数据，对它所描述的符号进行抽象。例如，一个函数被抽象为它的链接类型，它所包含的指令数量，以及可选的剖析信息（PGO）。此外，对另一个全局的每一个引用（采取的地址，直接调用）都被记录下来。这些信息可以在Thin link阶段建立一个完整的引用图，并利用全局总结信息进行后续快速分析。&lt;/p&gt;

&lt;p&gt;下面图片是LTO和ThinLTO的编译对比图；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/win2022/20230314084435.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ipo&quot;&gt;IPO&lt;/h2&gt;

&lt;p&gt;过程间分析（inter-procedural analysis）是一个多步骤的过程，是LTO分析过程中的重要部分，也是一个跨模块的分析过程。跨模块的优化功能实现最早在1987年（Link time optimization - MIPS），后来相继出现了过程间分析和转换，动态链接程序的优化（IPA + LTO）。&lt;/p&gt;

&lt;p&gt;GCC中的IPA包含的操作有： increase alignment、devirtualization、constant propagation、inline、pure/const analysis等。&lt;/p&gt;

&lt;p&gt;ICC中的IPO（Interprocedural Optimization）包含众多的优化，例如：Array dimension padding、Alias analysis、Constant propagation、Dead call deletion、Dead function elimination、Inlining、Structure splitting and field reordering、Whole program analysis等重要优化过程。优化选项配置为-ipo。&lt;/p&gt;

&lt;p&gt;比如inline内联优化。&lt;/p&gt;

&lt;h3 id=&quot;inline内联优化&quot;&gt;inline内联优化&lt;/h3&gt;

&lt;p&gt;内联（inline）优化就是把调用的函数放到调用的地方，避免函数调用和寄存器的分配，增加指令的数量。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 内联优化后&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myNum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;优化后，取消函数调用的好处&lt;/p&gt;

&lt;p&gt;1.它消除了函数调用过程中所需的各种指令：包括在堆栈或寄存器中放置参数，调用函数指令，返回函数过程，获取返回值，从堆栈中删除参数并恢复寄存器等。&lt;/p&gt;

&lt;p&gt;2.由于不需要寄存器来传递参数，因此减少了寄存器溢出的概率。当使用引用调用（或通过地址调用或通过共享调用）时，它消除了必须传递引用然后取消引用它们。&lt;/p&gt;

&lt;p&gt;除了有点，也有缺点：优化后的执行程序包变大。还有一些特定情况，内联将会造成很严重的后果，如递归函数的内联可能造成代码的无限inline循环。所以编译器在这些特殊情况下会拒绝内联，常见的包括虚调用，函数体积过大，有递归，可变数目参数，通过函数指针调用，调用者异常类型不同，declspec宏、使用alloca、使用setjump等。&lt;/p&gt;

&lt;p&gt;可以通过关键字：inline来实现内联优化。&lt;/p&gt;

&lt;p&gt;其实内联inline只是建议性的关键字，编译器并不一定会听你的，毕竟他比你更了解你的代码编译后是什么样子的，而所谓的内联也不单单是指inline这个关键字了，他本质上是一种编译器的优化方式。另外，在windows上平台我还经常能看到【forceinline】（GCC上的【always_inline】）这样的关键字，字面意思是强制内联。不过经过查阅，发现一般只是对代码体积不做限制了，或者说在Debug模式（不不开启优化的情况）下也会尽量按照开发者的意愿去内联。无论如何，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最终的决定权还是交给编译器去处理&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;死代码码消除-deadcode-elimination&quot;&gt;死代码码消除 (Deadcode Elimination)&lt;/h2&gt;

&lt;p&gt;故名思义，就是一段代码没用上就会被删去。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;233&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中，a和b实际在后面的代码中没有用到，所以编译的时候可以直接优化掉，将被转换为&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;学习东西要有耐心，不要着急，不要焦虑，否则会影响自己的信心。要循序渐进，关键是保持持续的学习动力。 编译器优化的内容很多，不必一次掌握。要逐个理解每个概念和原理。&lt;/p&gt;

&lt;h2 id=&quot;更多阅读&quot;&gt;更多阅读&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://grin-compiler.github.io/&quot;&gt;GRIN Compiler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36287943/article/details/103930336&quot;&gt;编译优化之 - 过程间优化(IPA/IPO)入门&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50812510&quot;&gt;被知乎大佬嘲讽后的一个月，我重新研究了一下内联函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/docs/LinkTimeOptimization.html#example-of-link-time-optimization&quot;&gt;example-of-link-time-optimization&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html&quot;&gt;thinlto-scalable-and-incremental-lto&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chasays.github.io/&quot;&gt;github博客&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;微信公众号：cdtfug， 欢迎关注一起吹牛逼，也可以加微信号「xiaorik」朋友圈围观。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 13 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/13/compiler-thinlto/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/13/compiler-thinlto/</guid>
        
        <category>gcc</category>
        
        <category>compiler</category>
        
        <category>optimization</category>
        
        
      </item>
    
      <item>
        <title>80 - 适者生存</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;今天看到冯大的一篇文章，&lt;a href=&quot;https://mp.weixin.qq.com/s/zN8vBAjrPh9nA0Q-kjnBWA&quot;&gt;我是这么看腾讯 T13 技术大佬被裁这事儿的&lt;/a&gt;，一个腾讯T13技术大佬被裁事件。&lt;/p&gt;

&lt;p&gt;技术专家在公司工作很多年而被裁，换了谁心里头都不舒服。对于当事人总结的被裁原因，往往又不是真正的原因，这就是所谓的当局者迷。&lt;/p&gt;

&lt;p&gt;作者给出了几个职场建议，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;包括低头干活，抬头看路，改变自己适应环境，以及让个人和公司相忘于江湖&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最近恰好听播客，接触到了一本书「高效能人士的7个习惯」,听名字就很鸡汤，但是里面对于职场新人来说，干货满满，豆瓣评分8.5。&lt;/p&gt;

&lt;p&gt;什么是彼得原理喃？&lt;/p&gt;

&lt;p&gt;指出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一个人在组织内部会得到晋升，直到不能胜任为止&lt;/code&gt;。也就是说，某个人在组织内部的管理层级，最终会达到自己无法胜任的位置。这意味着，即使一个人已经得到了晋升，但如果没有适当的培训和支持，他将无法胜任他晋升到的职位，会成为他的天花板。&lt;/p&gt;

&lt;p&gt;比如有一个程序员，他很擅长编写代码，并且在编写小型项目时表现优异。但是，当他被提升为高级软件工程师时，他可能会发现自己无法对应复杂和较大规模的项目，并且无法与团队进行沟通，或者无法承担管理职责。&lt;/p&gt;

&lt;p&gt;尽管他在代码方面很优秀，但是他可能会陷入自己的无能之境。他的上司可能会意识到他不能完成高级软件工程师的工作，并将他排除在项目外，或者将他降回到程序员或其他适合他的职位。&lt;/p&gt;

&lt;p&gt;但是在这里，有时候这个程序员可能也会变得太重要，团队已经习惯了他的存在，不能失去他，于是他就会继续留在这个职位上，直到他自己离开或者公司以某种方式解决这个问题。&lt;/p&gt;

&lt;p&gt;这个例子说明了在职场上，员工可能会被升迁到他们的无能之境，这不仅对他们本人不利，而且还对公司和团队产生负面影响。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5cW_LyfGRBoiYZYKi-eB4g&quot;&gt;想让我的方法更容易持续、更容易参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者的第六个年头的财务自由计划，她每年会整理过去的有价值的内容并定期更新分享给读者。文章重点在于如何获得10%的年度投资收益，从而达到财务自由的目标。作者强调了专业人士的专业知识的重要性，比如基金经理的投资建议等等。她建议投资者进行分散投资，使用能够跟踪表现最佳股票型基金平均收益的基金。作者还分享了她使用投资顾问和FOF来跟踪投资回报的经历和体验。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/E2KnibkYlVT4cgmd3QH1Kw&quot;&gt;无痛分娩，为什么还有 70% 产妇用不上？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;胡佳（化名）是一线城市三甲综合医院的麻醉科医生。和大家普遍想象的不同，胡佳所在的医院，产妇选择无痛分娩的比例是 100%。&lt;/p&gt;

&lt;p&gt;而在 19 年前，这个数据还只有 1%。据不完全统计，2004 年前仅有不足 1% 的国内产妇享受到分娩镇痛，即使在较发达地区分娩镇痛率仍不足 10%，而在边疆偏远地区，分娩镇痛更是一片空白。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwODQ3NjU5Ng==&amp;amp;mid=2247483986&amp;amp;idx=1&amp;amp;sn=995667b91c52664c265e5f65e2a8f59a&amp;amp;scene=58&amp;amp;subscene=0&quot;&gt;阿强买基金，为啥没人能卷走他的钱？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;把枯燥无趣的金融知识，用漫画的新式来传达，我觉得太有趣了。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cocktailpeanut.github.io/dalai/#/&quot;&gt;自动安装LLM模型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在你的电脑上运行LLaMA的简单方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/camenduru/stable-diffusion-webui-colab&quot;&gt;stable diffusion的webui colab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过一个草图的形式就可以自动生成一个漂亮的图片，结合google colab,免费部署和使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://shots.so/&quot;&gt;shots截图工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各种样式的截图边框。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/microsoft/visual-chatgpt&quot;&gt;visual-chatgpt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;微软自家的Visual ChatGPT连接了ChatGPT和一系列的Visual Foundation模型，以便在聊天过程中发送和接收图像。&lt;/p&gt;

</description>
        <pubDate>Sat, 11 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/11/Survival-of-the-fittest/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/11/Survival-of-the-fittest/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>79 -  技能速成</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;去年成都由于疫情，还有就是高温的原因，work from home，在家办公的日子就是舒服，不用考虑通勤时间，起床就可以开电脑，然后再去洗漱……&lt;/p&gt;

&lt;p&gt;慢慢的觉得在家办公特别爽，主要是我现在每天的通勤时间在1个小时。之前出门比较晚，出门就开始堵车，一天通勤时间在2~3个小时。用这个时间来做点自己喜欢的事情，应该是不错的。&lt;/p&gt;

&lt;p&gt;很久以前，关注过远程工作的时候，顺便推荐一个远程工作的社区：电鸭社区。发现里面前端岗位是最多的，后来就学习了一段时间的前端工程，诠释了什么是从入门到放弃。最主要的还是没有实际的工程来搞，就没那么容易记住。俗话说得好： talk is cheap, show me code.&lt;/p&gt;

&lt;p&gt;最近自己捣鼓一个前端工程，不管多晚，多累，就喜欢调试出来结果才罢休，一度我以为自己是不是真的兴趣爱好是这个做前端开发。&lt;/p&gt;

&lt;p&gt;前端是一个变化特别快，技术栈更新迭代快，如果自己不是一个爱学习，按钻研的性格，很难做的优秀。为了学习前端js用法，最近自己找了一个项目用js实现一个编译器流程的项目，找到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;项目结合当前学习的东西，这样才更容易掌握和速成&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面是chatGPT的回答，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;关于如何使前端开发变得有趣？格式为：观点1、观点2&lt;/code&gt;  （chatgpt的prompt非常重要，你看我把格式都给出来了，结果也不会差太远了，所以后面会不会有prompt engineer，不好说呀。）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;作为一个前端开发人员，有很多方法可以使工作更有趣：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;学习新技能和工具 - 不断学习新的技术和工具可以使前端开发总是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;保持新鲜感&lt;/code&gt;，同时也可以提高自己的技能水平。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;参加社区活动 - 参加线下或者线上的前端开发社区活动可&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;以认识更多志同道合的人&lt;/code&gt;，扩展自己的人脉，同时也可以学习到最新的前端技术发展趋势。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实战练习 - 通过完成一些实际项目的练习，可以让自己的技能更快地提高，同时也可以增加对前端开发的兴趣和热情。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;做自己感兴趣的项目 - 在自己的空闲时间，可以做一些自己感兴趣的前端开发项目，例如搭建自己的博客网站、构建一个自己喜欢的应用等等，这样可以让自己更加投入到前端开发中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加入开源社区 - 加入一些开源社区可以得到更广泛的技术交流和学习经验，同时也可以通过提交自己的代码或者修复别人的缺陷来积累自己的经验。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;与其他开发人员合作 - 与其他开发人员合作可以让前端开发更有趣，可以借鉴其他人的经验和技能，并且在合作中加深人际关系，增加团队协作和创造的乐趣。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我发现自己特别着迷的就是，自己撸一个后端的接口，然后前端拿到数据之后渲染那个感觉，太爽了。说不上来为啥。&lt;/p&gt;

&lt;p&gt;关于后端接口，不用掌握Java，Python里面有一个fastapi就可以在10行代码内完成，以及熟悉各种接口的调用方式和数据传递方式。如果你熟练地掌握了这些技能，你可以很容易地开发出健壮的接口，并且灵活地应对客户端的需求变化。另外，你也可以关注一些有关接口相关的博客、技术文章等渠道，了解行业最新的接口开发趋势，不断提升自己的技能水平。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://learningpromt.wiki/&quot;&gt;chatGPT提示工程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;里面提到的几个小技巧，已经在使用了，非常好用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://catcoding.me/p/apple-perf/&quot;&gt;苹果：为了安全让 M2 吃灰&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文介绍了苹果计算机在运行Rust编译器项目上的性能问题，以及它的根源 - System Integrity Protection（SIP）。SIP是苹果操作系统的一项安全技术，目的是阻止未经授权的代码执行，从而保护系统完整性。然而，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SIP会在执行任意代码之前对其进行校验，并可能发送网络请求以确保文件的安全性&lt;/code&gt;。这对于需要执行大量代码的开发人员来说可能会产生问题，因为SIP会降低系统的性能，并导致长时间运行的代码在苹果计算机上速度较慢。虽然可以通过禁用SIP来解决这个问题，但这也会降低计算机的安全性。作者认为，苹果公司在这个问题上没有给出一个充分的解决方案，这可能表明苹果对于开发者的重视程度已经不如以前了。&lt;/p&gt;

&lt;p&gt;文章还提供一些bypass的策略。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5JnKZ4MTnk8Hl_Jiz3DF4A&quot;&gt;关于南极旅游 - 王叔特别篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;王叔就是一个典范，无所畏惧，勇于尝试，才能拥有更大，更广阔的舒适区，让自己可以更好的去欣赏世界，享受人生。&lt;/p&gt;

&lt;p&gt;这其实无关财富，语言能力。王叔用自己的经历证明，用极为克制的预算，极为有限的语言能力，一样可以做到。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://glarity.app/google-summary&quot;&gt;谷歌总结内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输入视频，可以直接总结视频的内容， 还有一个链接：https://youtu.be/5Lh4qiB3STo&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://newsletter.pragmaticengineer.com/p/why-did-google-close-its-coding-competitions&quot;&gt;为什么谷歌关闭了代码竞赛&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Google 关闭持续了 20 年的编程比赛。这些比赛每年吸引近 30 w 开发者。这些年，Goolge 员工数目从 2004 年的 3000 人翻了 60 倍，而编程比赛是招人的一个重要手段，也开启了 IT 行业面试刷题的时代。最近因为减成本，组织比赛的员工很多被开了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://citw.dev/tutorial/create-your-own-compiler&quot;&gt;创建自己的编译器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将对杰米·凯尔的《超级小编译器》进行指导演练。超级微型编译器是一个用Javascript编写的简单编译器，我们将从头开始逐步编写它。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lxgw/LxgwWenkaiTC&quot;&gt;开源字体wenkai&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本字體的字形調整參考 一點字坊「傳承字形標準化文件」，但並不追求完全遵循之，有些部件會視情況做出取捨（如「曰」部件、「艹」部件等，由於涉及的漢字數量較多，故並未按照「檢校表」做改動；此外本字體中的部分部件採用了「檢校表」中收錄的一些稍爲遷就美觀需要的常見字形，如「蔑」「益」「亟」「老」「殳」等部件）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/swc-project/swc/tree/main/crates&quot;&gt;swc-project小项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSS、JavaScript、HTML 的 Parser 都手动实现了一遍。&lt;/p&gt;

&lt;p&gt;这个项目里面的子项目多得令人发指！且每个子项目的代码量都不少。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Mar 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/03/04/quick-skill/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/03/04/quick-skill/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
      <item>
        <title>78 -  继续搞钱</title>
        <description>&lt;p&gt;朋友，您好 ~&lt;/p&gt;

&lt;p&gt;我有一个小习惯，就是每次用了不管是多少钱，都会记录一下。&lt;/p&gt;

&lt;p&gt;之前记账只记录金额，没有具体的花销事项，导致时间一长就可能忘记。现在几张都会记录具体每一笔的用途是什么，买了什么。&lt;/p&gt;

&lt;p&gt;在开始阅读之前，大家先思考下，记账的好处是什么？&lt;/p&gt;

&lt;p&gt;我自己记账的时间，我看了下快有 5 年了。发现去年的支出比前年支出上浮了 10%，不知道是不是物价上涨的原因。去年全年支出 143,824 元，不包含房贷和其他贷款，基本上就是为了生活的开支。&lt;/p&gt;

&lt;p&gt;从去年的饼状图来看，依次是发红包 &amp;gt; 房贷 &amp;gt; 医疗 &amp;gt; 数码 &amp;gt; 三餐 &amp;gt; 孩子，没有想到三餐居然在数码之后，这部分要好好的反思下，有些数码的东西，如果是刚需才购买。&lt;/p&gt;

&lt;p&gt;看到有个方法，我&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不喜欢「克制」自己的消费，更喜欢理想的消费&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;就是把自己喜欢的东西加入到购物车，过一段时间再来看看，是不是自己想要的，如果是想要的，那说明当时不是冲动消费。&lt;/p&gt;

&lt;p&gt;2023 年的开支争取不增加，这个做到不是特别难，因为在数码这一块已经换的才换不久。但是由于大家都知道前不久，我们国家老人越来越多了，所以要准备点钱买入作为以后养老使用。&lt;/p&gt;

&lt;p&gt;医疗险、重疾险、储蓄养老有合适的产品可以再补充部分。&lt;/p&gt;

&lt;p&gt;除了开支外，还有一个重要反向节省的地方就是开源。&lt;/p&gt;

&lt;p&gt;「保持通话」播客里面有提到一个清单，除了支出外，还得有多个收入，大家都懂，不要把鸡蛋放在同一个篮子里面，这样的风险高。&lt;/p&gt;

&lt;p&gt;我除了上班，几乎没有其他的收入来源。收入单一，哪一天被裁员，或者毕业，就很危险。&lt;/p&gt;

&lt;p&gt;也要搞一搞 side project，你们有没有好的副业推荐的呀。&lt;/p&gt;

&lt;p&gt;如果您喜欢这份Newsletter，&lt;a href=&quot;https://chasays.zhubai.love/&quot;&gt;请转发给您朋友，&lt;/a&gt;，这是对我最大的帮助，继续进步，继续给大家带来有价值的分享。&lt;/p&gt;

&lt;h1 id=&quot;文章推荐&quot;&gt;文章推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDU1Mzg3Mw==&amp;amp;mid=2651483959&amp;amp;idx=1&amp;amp;sn=f4d3fa555806fc8e2bfc619e0cac7126&amp;amp;chksm=bdbdcd498aca445f90195daa4c0e0b430a86979f6a8dc6b17fe7dde60f117299393a6a4c82d4&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0227zBHxofXi1YOw21BMlpwo&amp;amp;sharer_sharetime=1677468259838&amp;amp;sharer_shareid=e73f8d7af2e8f1807ea7886e4c9a51c0&amp;amp;key=4b2e4dea11a1f06c147f211fbf1a783927b64bd2796389c6dc37d85a788c39438d73b4e19d5636e0205b7a8c3b17877cc9910f7d4374f7514313c6a9c0113c693abd5bb7d7e5de34fd252743054d7e0a210faf593b7c50d057ab52219dc2224058a4cc695f9d80ac85747a6d2bf1ac5cfa7ad6570aa8d1bfab94fa60a6f7cb7d&amp;amp;ascene=1&amp;amp;uin=NDA3MDQzMDU%3D&amp;amp;devicetype=Windows+11+x64&amp;amp;version=6309001c&amp;amp;lang=zh_CN&amp;amp;countrycode=CN&amp;amp;exportkey=n_ChQIAhIQKwubYTHDbvfedvvOlw9EsBLmAQIE97dBBAEAAAAAANi3Es09oWkAAAAOpnltbLcz9gKNyK89dVj0ln5yEK%2BqqT4DlE7Yor2j7sS2OfyEawJkDGDimfSrBJYW8A8wYueumgWLIePTadu%2F%2FTwsNcm3AABWbK1L2FuSVMSUR2hd5cZmjc4ifhzL2QFlahi4OYz1IaYbrnYodqKFwRZ6aZnsCbVvjLi4r7HZt09QKVMJ5PhbZ76SqvxUFXqYI6v63HGVkDl%2FkFZoO5qI1RruP0EsQDswxZ5njMSdvXijyUm1NoQGlxfIO2FjDBDokndeAxW7SadaCBcVndIt&amp;amp;acctmode=0&amp;amp;pass_ticket=DpZtvWuZp0su4Ublg8CIcroF2PGsiOxMjS%2F79ndbjarXh%2BcmFYK3sGTzKdStauJMQnp2RzA0JmaqZeFNrBmHKA%3D%3D&amp;amp;wx_header=1&amp;amp;fontgear=2&quot;&gt;教师过剩、高校关停，人口如何影响教育？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与在校生数变化趋势类似，2020~2035年我国义务教育阶段专任教师需求量总体减少，按现行生师比标准，到2035年全国将有约150万小学教师、37万初中教师过剩，小学教师需求量过剩较大，初中教师先短缺后过剩。
为应对这些过剩，除缩小班级规模、降低生师比外，未来应在稳定部属和省属师范大学招生计划的同时，逐步减少师专和高职高专的师范生招生，保持一定的师资规模和质量。另外，师资培养体系也要调整，调整师范专业设置，扩大音、体、美、劳、通用技术、学前、托育和特教等学科招生人数，减少文化科目招生计划。实际上，现在的师资供给存在较为严重的结构性缺编，语数等大课类老师相对容易过剩，而艺术、体育、科学等小课类老师更为短缺。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5cZkmPICwj3RM3PlfUM7rg&quot;&gt;首轮关停潮已来，幼儿园“一孩难求”&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;往年3月到8月，她每天都会接到大量咨询和报名电话，很多家长还要给孩子排队等位。&lt;/p&gt;

&lt;p&gt;希望，国家能尽快出台一个关于托育的细化政策，列出收费等方面的参考标准，目前仍是以各地摸索为主。“我们一定注意不要走幼儿园走过的弯路，应尽快把托育机构的性质有个明确的定位。”柳倩说。另外，托育老师的专业性和综合性要求很高，国内还缺乏一套成系统的托育教师培养体系，这方面也应进一步加强。&lt;/p&gt;

&lt;h1 id=&quot;工具资源推荐&quot;&gt;工具、资源推荐&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/liupan1890/aliyunpan/issues/714&quot;&gt;阿里云盘个人开发者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者前几天刚刚确认找到了新工作（之前回老家被隔离就是在办这个事），以后不跑美团了，新工作是做出纳，嗯，现金出纳&lt;/p&gt;

&lt;p&gt;从程序员转到外卖员转到出纳，这个跨度有点大，所以接下来一段时间需要从零开始学出纳，这个比较耗精力。为了避免因为啥也不会被开除，因此会暂时停止v3的开发工作，等我熟悉了出纳的工作事宜，再继续开发&lt;/p&gt;

&lt;p&gt;程序是爱好，不会停止，也无法割舍
出纳是生活，我已经穷的到了一定地步了，要养家，要想我媳妇问我今天超市搞活动一瓶2L可乐活动价5.5元买不买。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/OwO-Network/DeepLX&quot;&gt;DeepLX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用Golang编写的永久免费的DeepL API，在mac上配合bob，就很方便的使用deepl的精准翻译功能。
https://github.com/clubxdev/bob-plugin-deeplx&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cfortuner/promptable&quot;&gt;promptable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Promptable是一个库，它可以让你用LLMS和嵌入提供商(如OpenAI、Huging Face、Cohere和Anthropic)构建强大的AI应用程序。它提供了灵活且可扩展的API，使您可以轻松地将LLM与数据和工具组合在一起，从而快速轻松地构建复杂的应用程序。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Feb 2023 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2023/02/25/make-more-money/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2023/02/25/make-more-money/</guid>
        
        <category>Newsletter</category>
        
        
      </item>
    
  </channel>
</rss>
