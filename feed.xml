<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>察说花园</title>
    <description>察说花园是一个关于我个人的学习记录过程，五花八门，关于互联网、TensorFlow、车载、安卓、音视频、存储、小程序和编译器的资讯和技术分享</description>
    <link>https://blog.chiphub.top/</link>
    <atom:link href="https://blog.chiphub.top/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 15 Oct 2024 09:00:57 +0000</pubDate>
    <lastBuildDate>Tue, 15 Oct 2024 09:00:57 +0000</lastBuildDate>
    <generator>Jekyll v3.10.0</generator>
    
      <item>
        <title>智能合约 学习记录 1</title>
        <description>&lt;h1 id=&quot;read-more&quot;&gt;read more&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://liaoxuefeng.com/books/blockchain/ethereum/smart-contract/index.html&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/09/11/smart-contract-guide/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/09/11/smart-contract-guide/</guid>
        
        <category>智能合约</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器最佳实践 - 后端</title>
        <description>&lt;h1 id=&quot;simt-是什么意思&quot;&gt;SIMT 是什么意思？&lt;/h1&gt;

&lt;p&gt;Single Instruction Multiple Threads” (SIMT) 单指令多线程。&lt;/p&gt;

&lt;p&gt;在纯 SIMD 中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一条指令以完全相同的方式作用于所有数据&lt;/code&gt;。
在 SIMT 中，这一限制有所放松：可以激活或停用选定的线程，以便仅在活动线程上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;处理指令和数据，而在非活动线程上本地数据保持不变。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因此，SIMT 可以适应分支，尽管效率不高。给定以 if (条件) 开头的 if-else 构造，当运行 if 子句中的语句时，condition==true 的线程将处于活动状态，而当运行 else 中的语句时，condition==false 的线程将处于活动状态条款。结果应该是正确的，但非活动线程在等待活动子句中的语句完成时不会执行任何有用的工作。SIMT 内的分支如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;simd_if.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Volta 之前的 NVIDIA GPU 中，整个 if 子句（即语句 A 和 B）必须由相关线程执行，然后整个 else 子句（语句 X 和 Y）必须由相关线程执行其余线程，则所有线程在继续执行之前都必须同步（语句 Z）。Volta 更灵活的 SIMT 模型允许在中间点（例如 A 和 X 之后）同步共享数据。&lt;/p&gt;

&lt;p&gt;这些不同的语句块在不同的线程里面，我们知道 GPU 都是并行运行的。那么这些线程都是执行的同一个命令，那结果怎么处理？&lt;/p&gt;

&lt;h1 id=&quot;warp&quot;&gt;warp&lt;/h1&gt;

&lt;p&gt;warp 是什么意思？&lt;/p&gt;

&lt;p&gt;指的是编织者的梭子穿过的一组垂直线-warp，为了后面更形象的理解吧。顺便说一下横着的是 weft。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;warp-1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在编程技术里面，是这个意思：The term warp originates from weaving, the first parallel-thread technology.&lt;/p&gt;

&lt;p&gt;在运行时，线程块被分为多个线程束以供 SIMT 执行。一个完整的 warp 由一组具有连续线程索引的 32 个线程组成。然后，warp 中的线程由一组 32 个 CUDA 核心一起处理。这类似于 CPU 上的向量化循环被分成固定大小的向量，然后由一组向量通道进行处理的方式。&lt;/p&gt;

&lt;p&gt;将线程捆绑为 32 个线程束的原因很简单，在 NVIDIA 的硬件中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CUDA 核心被分为固定的 32 个组&lt;/code&gt;。将大线程块分解成这种大小的块可以简化 SM 在其可用资源上调度整个线程块的任务。&lt;/p&gt;

&lt;p&gt;这个图，大家应该看到很多很多次了吧。&lt;/p&gt;

&lt;h1 id=&quot;read-more&quot;&gt;read more&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://cvw.cac.cornell.edu/gpu-architecture/gpu-characteristics/simt_warp&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/06/13/simt-warp/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/06/13/simt-warp/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>后端</category>
        
        
      </item>
    
      <item>
        <title>LLVM 快速入门 - 后端</title>
        <description>&lt;p&gt;如何快速的入门 llvm 后端？&lt;/p&gt;

&lt;h2 id=&quot;ide工具&quot;&gt;IDE工具&lt;/h2&gt;

&lt;p&gt;推荐一个工具clion：这个没有社区版的， 用付费的就可以， 其他的我不知道。&lt;/p&gt;

&lt;p&gt;有个trace功能，1个函数调用路径，然后右键查看源码可以跳转到源码里面去。&lt;/p&gt;

&lt;h2 id=&quot;操作系统&quot;&gt;操作系统&lt;/h2&gt;

&lt;p&gt;windoows， 不管是多大的项目，只要debug，几秒就可以调到断点的地方。&lt;/p&gt;

&lt;p&gt;我用的m1电脑，编译慢，调试而慢，应该是对于debug没有优化，windwos是 debug是优化过的。&lt;/p&gt;

&lt;p&gt;有懂的大佬可以留言，我学习学习。&lt;/p&gt;

&lt;h2 id=&quot;关于编译&quot;&gt;关于编译&lt;/h2&gt;

&lt;p&gt;装一个 c cache， 编译成动态库， 可以缓存编译的文件， 速度会快很多。&lt;/p&gt;

&lt;h2 id=&quot;关于寄存器的分配&quot;&gt;关于寄存器的分配&lt;/h2&gt;

&lt;p&gt;llvm太复杂了，寄存器分配那个地方非常难搞。&lt;/p&gt;

&lt;h2 id=&quot;学习后端pass&quot;&gt;学习后端pass&lt;/h2&gt;

&lt;p&gt;debug的速度决定了理解这个项目的速度，先了解这个pass是干什么的。&lt;/p&gt;

&lt;p&gt;首先，想如果是你你会怎么写，然后去代码里面找你脑中会怎么写的代码片段。&lt;/p&gt;

&lt;p&gt;对于GPU编译器， 看amd的编译器，在里面乱写，就改其中的1-2行，看看预期效果怎么回事，多弄几遍这个就会了。&lt;/p&gt;

&lt;h1 id=&quot;more&quot;&gt;more&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.jetbrains.com/clion/download/&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 01 Jun 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/06/01/llvm-learning-end/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/06/01/llvm-learning-end/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>后端</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器最佳实践 - 后端</title>
        <description>&lt;p&gt;学习内容来自网络课程，这个基本上是针对有点经验的 llvm 开发者，前面的就是过一遍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://books.google.com.tw/books?id=g_wqEAAAQBAJ&amp;amp;printsec=copyright&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用-passmanager-和-analysismanage&quot;&gt;使用 PassManager 和 AnalysisManage&lt;/h2&gt;

&lt;h2 id=&quot;处理-llvm-ir&quot;&gt;处理 LLVM IR&lt;/h2&gt;
&lt;h2 id=&quot;准备相关的工具&quot;&gt;准备相关的工具&lt;/h2&gt;
&lt;h2 id=&quot;学习-llvm-ir-表达式&quot;&gt;学习 LLVM IR 表达式&lt;/h2&gt;

</description>
        <pubDate>Sat, 01 Jun 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/06/01/llvm-learning-best_practice-2/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/06/01/llvm-learning-best_practice-2/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>后端</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器最佳实践 - 构建，Cmake 和 test</title>
        <description>&lt;p&gt;学习内容来自网络课程，这个基本上是针对有点经验的 llvm 开发者，前面的就是过一遍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://books.google.com.tw/books?id=g_wqEAAAQBAJ&amp;amp;printsec=copyright&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-构建技巧&quot;&gt;1. 构建技巧&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用 ninja 构建&lt;/li&gt;
  &lt;li&gt;指定 lld 或者是 gold 的链接器&lt;/li&gt;
  &lt;li&gt;用特定的 cmake 参数来构建&lt;/li&gt;
  &lt;li&gt;构建不同的类型；debug，release，RelWithDebInfo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个我试了，RelWithDebInfo 又慢又大
 release，又快又小，如果不 debug 的话，用这个不错；
 debug 编译慢，空间占用的也非常的大。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;构建指定的目标 target， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD=&quot;X86;AMDGPU&quot; …&lt;/code&gt; ,有针对性的编译，速度会快很多；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建动态库： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DBUILD_SHARED_LIBS=ON&lt;/code&gt; 链接静态库通常比链接动态库花费更多的时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 gn 来编译，我没有成功；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM 的 GN 支持位于 llvm/utils/gn 文件夹中。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-llvm-里面-cmake-用法&quot;&gt;2. llvm 里面 Cmake 用法&lt;/h2&gt;

&lt;p&gt;lib 是 LLVM 框架的基本构建块。&lt;/p&gt;

&lt;h3 id=&quot;cmake-添加新的库&quot;&gt;CMake 添加新的库&lt;/h3&gt;

&lt;p&gt;不要用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_library&lt;/code&gt;，要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_component_library&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# In an in-tree CMakeLists.txt file…
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyLLVMPass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SHARED&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MyPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LLVM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;library&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么不要用这个？主要就是慢，而且不好扩展和控制。&lt;/p&gt;

&lt;h3 id=&quot;llvm-更喜欢使用全局-cmake-参数-即-build_shared_libs-来控制所有的组件库是静态构建还是动态构建使用内置指令很难做到这一点的&quot;&gt;LLVM 更喜欢使用全局 CMake 参数 (即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILD_SHARED_LIBS&lt;/code&gt;) 来控制所有的组件库是静态构建还是动态构建。使用内置指令很难做到这一点的&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LLVM 更喜欢使用一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;全局的 CMake&lt;/code&gt; 参数来控制一些编译标志&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# In a CMakeLists.txt
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_component_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVMFancyOpt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FancyOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里，LLVMFancyOpt 是库名，FancyOpt.cpp 是源文件。&lt;/p&gt;

&lt;p&gt;注意下面 2 个用法是一样的：&lt;/p&gt;

&lt;p&gt;写到一个里面&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_component_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVMFancyOpt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FancyOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LINK_COMPONENTS&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Analysis&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScalarOpts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;分开写，先 link 组件：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVM_LINK_COMPONENTS&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Analysis&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScalarOpts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_llvm_component_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVMFancyOpt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FancyOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cmake-函数添加可执行文件和工具&quot;&gt;CMake 函数添加可执行文件和工具&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_executable&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_tool&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myLittleTool&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MyLittleTool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一个全局的 CMake 变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_BUILD_TOOLS&lt;/code&gt;，用来启用/禁用 LLVM 工具。&lt;/p&gt;

&lt;h3 id=&quot;cmake-函数添加-pass-插件&quot;&gt;CMake 函数添加 Pass 插件&lt;/h3&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_pass_plugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyPass&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HelloWorldPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LINK_COMPONENTS、LINK_LIBS 和 DEPENDS 参数也可以在这里使用，其用法和功能与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_component_library&lt;/code&gt; 相同。&lt;/p&gt;

&lt;h2 id=&quot;3-lit-测试&quot;&gt;3. lit 测试&lt;/h2&gt;

&lt;p&gt;LIT 是一个测试基础设施，最初是为运行 LLVM 的回归测试而开发的。主要配合 Filecheck 来用。&lt;/p&gt;

&lt;p&gt;书里面，没有提到的，我这里补充一个，就是最好用 llvm-lit 工具，而不是 lit（python 的 lib）。&lt;/p&gt;

&lt;p&gt;如果还有就是可以自动更新 lit 测试的检查点；工具位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/util/update_xxxx.py&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python update_xxx.py under_test_file.xx&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Fri, 31 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/31/llvm-learning-best_practice-1/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/31/llvm-learning-best_practice-1/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>测试</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：调试技巧</title>
        <description>&lt;p&gt;调试的时候有几个技巧，分享和记录下，方便自己后面可以熟练的用到。&lt;/p&gt;

&lt;h2 id=&quot;看所有的编译命令但是不执行&quot;&gt;看所有的编译命令，但是不执行&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-###&lt;/code&gt;，这个就是 clang 的第一个参数。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://clang.llvm.org/docs/CommandGuide/clang.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用 clang 编译的时候，会从打印（但不运行）为此编译运行的命令。&lt;/p&gt;

&lt;p&gt;然后打印出出错的命令，然后一步一步的执行，就知道是哪里的问题了。&lt;/p&gt;

&lt;p&gt;比如：优化或者是定位哪一步的编译时间过长，是词法解析，还是编译器后端，还是 lld 导致的，用这个方法分别执行每一步的命令，然后统计下，就知道是哪里耗费的时间长。&lt;/p&gt;

&lt;h2 id=&quot;llvm_debug-用法&quot;&gt;llvm_debug 用法&lt;/h2&gt;

&lt;p&gt;将对应的实例以字符串的形式输入到 errs() 流中，但是类似这种调试信息，我们通常并不想在正式发布的时候打印，而且有时候 Pass 的代码一多，就会造成打印的信息过多，干扰我们调试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://zhqli.com/post/1667466024&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;借助 LLVM 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_DEBUG&lt;/code&gt; 对调试信息进行分类，使用之前需要导入对应的头文件并定义 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DEBUG_TYPE&lt;/code&gt;, 如下所示&lt;/p&gt;

&lt;p&gt;在 llvm 代码里面可以看到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_DEBUG()&lt;/code&gt;的用法，这个用法是什么喃？&lt;/p&gt;

&lt;p&gt;用的时候需要在 cpp 顶部定义各一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#incldue DEBUG_TYPE &quot;pass_name&quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;举个例子&quot;&gt;举个例子&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AMDGPU 的 calllowering 里面。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define DEBUG_TYPE &quot;amdgpu-call-lowering&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;定义一个 debug_type 的，后面是 pass 的名字。如何使用，
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_DEBUG(dbgs())&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Make sure that they can fit on the caller&apos;s stack.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIMachineFunctionInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FuncInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIMachineFunctionInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OutInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getStackSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FuncInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getBytesInStackArgArea&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LLVM_DEBUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dbgs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;... Cannot fit call operands on caller&apos;s stack.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样 debug 的时候，只需要跟上这个 pass 的名字，就只打印出这个 pass 的相关的 log 信息了。定位就方便多了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opt xxx  --debug-only=amdgpu-call-lowering &lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;统计运行时间&quot;&gt;统计运行时间&lt;/h2&gt;

&lt;p&gt;上面提到如何用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;###&lt;/code&gt;来查看命令，那么还有如何通过执行直接获取每一个的执行时间？&lt;/p&gt;

&lt;p&gt;可以用这个命令通过 opt &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-time-trace&lt;/code&gt; 选项告诉 opt 导出所有由 TimeTraceaScope 收集的信息，并将 trace 文件保存到 -time-trace-file 指定的 json 文件中，这个 json 文件怎么查看呢？可以在 chrome 地址栏输入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chrome://tracing&lt;/code&gt;, 然后打开这个 json 文件即可可视化查看，是不是有点惊喜？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;2024-5-28-tracing.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击图片中第三个图标，就可以放大和缩小这个图片了，能看到具体是哪一个出了问题。&lt;/p&gt;

&lt;p&gt;chrome 的 trace 查看功能实际上是集成了项目 perfetto, 这个项目可以在线使用，地址是 https://ui.perfetto.dev/.&lt;/p&gt;

&lt;p&gt;那么 clang 里面用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ftime-trace&lt;/code&gt; 也是可以用的`。&lt;/p&gt;

&lt;p&gt;方便么？do you get it?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;顺便推荐一本书，就是短时间内学习有用的 LLVM 技能，并使您能够快速构建原型和项目。编程语言爱好者还会发现本书对于在 LLVM 的帮助下构建新的编程语言很有用。
https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有大佬翻译为中文了，https://github.com/xiaoweiChen/LLVM-Techniques-Tips-and-Best-Practies&lt;/p&gt;
</description>
        <pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/28/llvm-learning-debug/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/28/llvm-learning-debug/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：调试技巧 2 </title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这里直接推荐一个 https://blog.csdn.net/zhongyunde/article/details/109013865&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;工具的选项&quot;&gt;工具的选项&lt;/h1&gt;

&lt;p&gt;传递编译选项给 clang -cc1：-Xclang
-cc1 选项：实际的编译命令
传递编译选项给 llvm 编译：-mllvm
打印 token：-Xclang -dump-tokens
打印 AST： -Xclang -ast-dump
打印 llvm IR：-S -emit-llvm
打印汇编：-S
打印 pass 列表： -mllvm -debug-pass=Structure
打印 clang driver：-###
在 pass 执行完打印 IR：-mllvm -print-after-all；llc 也可以 -print-after-all, or stop-before=xx, stop-after=xx
DAGToDAG Debug 日志：-mllvm -debug&lt;/p&gt;

&lt;p&gt;选项-verify-each 能够使能每个 pass 后的验证&lt;/p&gt;

&lt;p&gt;打印模块信息： -print-module-scope，由于默认 print-after-all 仅在模块信息发生变化时才重新打印，导致过程中的 IR 内容不能直接用于 pass 的输入，因此配合此选项可以避免额外适配&lt;/p&gt;

&lt;p&gt;获取指定函数的 lr 文件：-mllvm -opt-bisect-limit=-1 -S -emit-llvm -filter-print-funcs=poo&lt;/p&gt;

&lt;p&gt;邮件 Which optimization pass deals with heap values 标题中提到选项-mllvm -print-changed 可以显示变化&lt;/p&gt;

&lt;p&gt;使用选项-mllvm –print-changed=quiet -mllvm –print-module-scope 查看状态变化，参考 Why is llvm.loop.unroll.disable appended for -O1 -emit-llvm - #2 by aeubanks - IR &amp;amp; Optimizations - LLVM Discussion Forums&lt;/p&gt;

&lt;h1 id=&quot;裁剪-case&quot;&gt;裁剪 case&lt;/h1&gt;

&lt;p&gt;a) 用例裁剪：llvm 提供 llvm-reduce 及使用示例&lt;/p&gt;

&lt;p&gt;~/test/issue2485/err » cat test1.sh                                                           &lt;br /&gt;
#!/bin/bash
opt  $1 -instcombine -S 2&amp;gt;&amp;amp;1 | grep SafeReplacementConstant # 匹配返回 0 是感兴趣
————————————————————
~/test/issue2485/err » llvm-reduce –test=test1.sh test-2485.ll
如果是 lto 优化，则需要使用-Wl,-plugin-opt=save-temps 保留中间文件，生成的&lt;em&gt;.opt.bc 使用 llvm-dis 转换为&lt;/em&gt;.ll 文件，后续裁剪方法同上&lt;/p&gt;

&lt;p&gt;llvm-dis a.out.0.4.opt.bc – 生成 a.out.0.4.opt.ll&lt;/p&gt;

&lt;p&gt;opt  -instcombine  a.out.0.4.opt.ll&lt;/p&gt;

&lt;p&gt;b) 源码裁剪：llvm 后端中的 llvm-reduce 只能对非后端的 IR 进行裁剪，无法对后端的 IR 进行裁剪。因此可以先使用 C-Reduce 对 C 源码裁剪，间接的进行简化，使用方法类似 llvm-reduce&lt;/p&gt;

&lt;p&gt;MIR 相关的调试补充介绍&lt;/p&gt;

&lt;p&gt;MIR 的调试参考 Machine IR (MIR) Format Reference Manual — LLVM 13 documentation&lt;/p&gt;

&lt;p&gt;You can use the MIR format for testing in two different ways:&lt;/p&gt;

&lt;p&gt;You can write MIR tests that invoke a single code generation pass using the -run-pass option in llc.
You can use llc’s -stop-after option with existing or new LLVM assembly tests and check the MIR output of a specific code generation pass.&lt;/p&gt;

&lt;p&gt;参考 CodeGen/AMDGPU/fold-reload-into-m0.mir，可以使用 -start-before=greedy -stop-after=virtregmap 指定开始和结束要执行的 pass, 也就是并不需要都重头开始执行，示例：&lt;/p&gt;

&lt;p&gt;llc -O3 reduced.ll -stop-before=virtregmap -o - &amp;amp;&amp;gt; machine-scheduler1.mir&lt;/p&gt;

&lt;p&gt;llc -O3 reduced.ll -simplify-mir -o - -print-after-all 也可以打印 mir&lt;/p&gt;

&lt;p&gt;注意： -o - 是关键，和 llc -O3 reduced.ll -stop-before=virtregmap -debug-only=machine-scheduler 得到的内容存在差异&lt;/p&gt;

&lt;p&gt;学习 mllvm -opt-bisect-limit 用法：Using -opt-bisect-limit to debug optimization errors — LLVM 15.0.0git documentation&lt;/p&gt;

&lt;p&gt;cgdb 类似 emacs + gdb 功能，可以实时查看代码执行位置，参考 https://blog.csdn.net/yzhang6_10/article/details/83626226&lt;/p&gt;

&lt;p&gt;IRbuilder 或者 MachineIRBuilder 是为了建新的语句的一个接口类，可以使用&lt;/p&gt;

&lt;p&gt;p Builder.GetInsertBlock()-&amp;gt;dump() 打印当前 basicblock 的信息&lt;/p&gt;

&lt;h1 id=&quot;3常用-debug-api查看过程状态&quot;&gt;3、常用 debug API，查看过程状态&lt;/h1&gt;

&lt;p&gt;p L.getHeader()-&amp;gt;getParent()-&amp;gt;dump()  查看循环体的内容&lt;/p&gt;

</description>
        <pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/28/llvm-learning-debug-2/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/28/llvm-learning-debug-2/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>调试</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：如何添加一个 builtin 函数 - 2</title>
        <description>&lt;p&gt;需要主要有一个地方。&lt;/p&gt;

&lt;p&gt;如果是 intrinsic*.td 里面使用了，ClangBuiltin&amp;lt;&amp;gt;, 那么就不需要再 CGBuiltin.cpp 里面添加枚举了。&lt;/p&gt;

&lt;h2 id=&quot;先来看一组定义的差别&quot;&gt;先来看一组定义的差别&lt;/h2&gt;

&lt;p&gt;定义 1&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_stackrestore&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultAttrsIntrinsic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm_anyptr_ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;ClangBuiltin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;__builtin_stack_restore&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;定义 2&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_stackrestore&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultAttrsIntrinsic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm_anyptr_ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这两个定义的主要区别在于是否将 LLVM 固有函数与 Clang builtin 函数关联。这确实是一个关键差别，影响到 Clang 如何处理 builtin 函数以及它们在 LLVM IR 中的表示。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClangBuiltin&amp;lt;&quot;__builtin_stack_restore&quot;&amp;gt;&lt;/code&gt; 表示这个固有函数在 Clang 中对应于 builtin 函数 __builtin_stack_restore。这意味着，当你在 C/C++ 代码中使用 __builtin_stack_restore 时，Clang 会将其转换为 LLVM IR 中的 llvm.stackrestore builtin 函数调用。&lt;/p&gt;

&lt;h2 id=&quot;没看懂举个例子&quot;&gt;没看懂，举个例子？&lt;/h2&gt;

&lt;p&gt;比如在 intrinsic.td 里面定义了&lt;/p&gt;

&lt;p&gt;https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/IR/Intrinsics.td&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_stackrestore&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultAttrsIntrinsic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm_anyptr_ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;ClangBuiltin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;__builtin_stack_restore&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ClangBuiltin&amp;lt;&quot;__builtin_stack_restore&quot;&amp;gt;;&lt;/code&gt;
Clang 内建函数关联：
ClangBuiltin&amp;lt;”__builtin_stack_restore”&amp;gt; 表示这个固有函数在 Clang 中对应于内建函数 __builtin_stack_restore。即，当你在 C/C++ 代码中使用 __builtin_stack_restore 时，Clang 会将它转换为 LLVM IR 中的 llvm.stackrestore 固有函数调用。&lt;/p&gt;

&lt;p&gt;有了这个，就不需要在 CGbuiltin.cpp 里面添加枚举了，添加了也不会走到枚举这里的。&lt;/p&gt;

&lt;p&gt;再来看看 ClangBuiltin&amp;lt;&amp;gt; 这个定义说的啥？&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;/// ClangBuiltin - If this intrinsic exactly corresponds to a Clang builtin, this&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;/// specifies the name of the builtin.  This provides automatic CBE and CFE&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;/// support.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ClangBuiltin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClangBuiltinName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;意思就是 ClangBuiltin 如果此内在 intrinsic 函数能完全对应于 Clang builtin 函数，则此指定 builtin 的名称，会自动支持 clang 前后端。&lt;/p&gt;

&lt;p&gt;还没看懂？别开玩笑了，我的零基础的都能看懂~&lt;/p&gt;

&lt;p&gt;还有一个问题，估计你和我一样，好奇，如果是 2 边都添加了，会怎么样？&lt;/p&gt;

&lt;p&gt;我试了，如过 intrinsic.td 里面添加了，又在 CGBuiltin.cpp 里面添加了。CGBuiltin.cpp 这个里面是不会生效的。&lt;/p&gt;
</description>
        <pubDate>Fri, 24 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/24/llvm-learning-define-intrinsics-2/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/24/llvm-learning-define-intrinsics-2/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器之美 - 后端基础：20~22</title>
        <description>&lt;p&gt;学习内容来自极客时间的付费课程，我是针对性的学习，直接进入后端的学习，从 20 讲开始，前端的词法解析，直接跳过。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://time.geekbang.org/column/intro/100034101&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;```graph TD&lt;/p&gt;

&lt;p&gt;A[前端] –&amp;gt; B{词法分析}
B –&amp;gt; C{语法分析}
C –&amp;gt; D{语义分析}
D –&amp;gt; E{生成中间代码}
E –&amp;gt; F{优化}
F –&amp;gt; G{生成目标代码}
G –&amp;gt; H[后端]&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;你是不是觉得汇编很难？&lt;/p&gt;

&lt;p&gt;不瞒你说，我一开始也觉得汇编好高级呀，看不懂呀，太难了。&lt;/p&gt;

&lt;p&gt;这个是什么鬼语法。其他汇编比高级语言简单，没有复杂的类型，没有多的语法结构。通常就是把数据拷贝到寄存器，处理一下，再保存回内存。&lt;/p&gt;

&lt;p&gt;只是我们见到的，都是高级语言，都是处理过的，辨识度高。&lt;/p&gt;

&lt;p&gt;为了降低后端工作量，提高软件复用度，就需要引入中间代码（Intermediate Representation，IR）的机制，它是独立于具体硬件的一种代码格式。各个语言的前端可以先翻译成 IR，然后再从 IR 翻译成不同硬件架构的汇编代码。如果有 n 个前端语言，m 个后端架构，本来需要做 m*n 个翻译程序，现在只需要 m+n 个了。这就大大降低了总体的工作量。&lt;/p&gt;

&lt;p&gt;像 Rust 就充分利用了 LLVM，GCC 的各种语言，如 C、C++、Object C 等，也是充分共享了后端技术。&lt;/p&gt;

&lt;p&gt;不得不说 rust 的开源社区建设太好了。&lt;/p&gt;

&lt;h2 id=&quot;代码分析和优化&quot;&gt;代码分析和优化&lt;/h2&gt;

&lt;p&gt;依赖于机器的优化，则是依赖于硬件的特征。现代的计算机硬件设计了很多特性，以便提供更高的处理能力，比如并行计算能力，多层次内存结构（使用多个级别的高速缓存）等等。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;编译器要能够充分利用硬件提供的性能&lt;/code&gt;，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;寄存器优化。对于频繁访问的变量，最好放在寄存器中，并且尽量最大限度地利用寄存器，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不让其中一些空着&lt;/code&gt;，有不少算法是解决这个问题的，教材上一般提到的是染色算法；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;充分利用高速缓存。高速缓存的访问速度可以比内存快几十倍上百倍，所以我们要尽量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;利用高速缓存&lt;/code&gt;。比如，某段代码操作的数据，在内存里尽量放在一起，这样 CPU 读入数据时，会一起都放到高速缓存中，不用一遍一遍地重新到内存取。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并行性。现代计算机都有多个内核，可以&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;并行计算&lt;/code&gt;。我们的编译器要尽可能把充分利用多个内核的计算能力。这在编译技术中是一个专门的领域。比如 NVIDIA 的 cuda&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;流水线。CPU 在处理不同的指令的时候，需要等待的时间周期是不一样的，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;在等待某些指令做完的过程中其实还可以执行其他指令&lt;/code&gt;。就比如在星巴克买咖啡，交了钱就可以去等了，收银员可以先去处理下一个顾客，而不是要等到前一个顾客拿到咖啡才开始处理下一个顾客。涉及到 data hazard&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指令选择。有的时候，CPU 完成一个功能，有多个指令可供选择。而针对某个特定的需求，采用 A 指令可能比 B 指令效率高百倍。比如 X86 架构的 CPU 提供 SIMD 功能，也就是一条指令可以处理多条数据，而不是像传统指令那样一条指令只能处理一条数据。在内存计算领域，SIMD 也可以大大提升性能，我们在第 30 讲的应用篇，会针对 SIMD 做一个实验。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其他优化。比如可以针对专用的 AI 芯片和 GPU 做优化，提供 AI 计算能力，等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;刚接触编译技术的时候，可能会把视线停留在前端技术上，以为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;能做 Lexer、Parser 就是懂编译了&lt;/code&gt;。实际上，词法分析和语法分析比较成熟，有成熟的工具来支撑。相对来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;后端的工作量更大，挑战更多，研究的热点也更多&lt;/code&gt;。比如，人工智能领域又出现了一些专用的 AI 芯片和指令集，就需要去适配。&lt;/p&gt;

&lt;h2 id=&quot;程序运行的环境&quot;&gt;程序运行的环境&lt;/h2&gt;

&lt;p&gt;下面这一段是我直接 copy 过来的，我还没有消化掉。后面慢慢看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般来讲，代码区是在最低的地址区域，然后是静态数据区，然后是堆。而栈传统上是从高地址向低地址延伸，栈的最顶部有一块区域，用来保存环境变量。&lt;/p&gt;

&lt;p&gt;代码区（也叫文本段）存放编译完成以后的机器码。这个内存区域是只读的，不会再修改，但也不绝对。现代语言的运行时已经越来越动态化，除了保存机器码，还可以存放中间代码，并且还可以在运行时把中间代码编译成机器码，写入代码区。&lt;/p&gt;

&lt;p&gt;静态数据区保存程序中全局的变量和常量。它的地址在编译期就是确定的，在生成的代码里直接使用这个地址就可以访问它们，它们的生存期是从程序启动一直到程序结束。它又可以细分为 Data 和 BSS 两个段。Data 段中的变量是在编译期就初始化好的，直接从程序装在进内存。BSS 段中是那些没有声明初始化值的变量，都会被初始化成 0。&lt;/p&gt;

&lt;p&gt;堆适合管理生存期较长的一些数据，这些数据在退出作用域以后也不会消失。比如，我们在某个方法里创建了一个对象并返回，并希望代表这个对象的数据在退出函数后仍然可以访问。&lt;/p&gt;

&lt;p&gt;而栈适合保存生存期比较短的数据，比如函数和方法里的本地变量。它们在进入某个作用域的时候申请内存，退出这个作用域的时候就可以释放掉&lt;/p&gt;

&lt;p&gt;关于优化，可以看这个里面的一些思路：我目前还没有看。https://www.agner.org/optimize/&lt;/p&gt;
</description>
        <pubDate>Fri, 24 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/24/llvm-learning-basic-1/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/24/llvm-learning-basic-1/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：TD 里面的 def、defm、defvar 有什么区别</title>
        <description>&lt;p&gt;前面学习了如何添加一个 intrinsic 函数的过程，发现有涉及到 td table gen 语言的格式，这个需要注意。&lt;/p&gt;

&lt;p&gt;有几个关键字，def，defm，defvar 的区别？&lt;/p&gt;

&lt;p&gt;这个内容非常的简单，使用的时候注意下即可。官方文档把这个称为 record，翻译过来是记录？anyway，随便是什么，记住就是一个标识符吧。&lt;/p&gt;

&lt;h1 id=&quot;首先了解下什么-single-class和-multiclass&quot;&gt;首先了解下什么 single class，和 multiclass&lt;/h1&gt;

&lt;p&gt;重要的一点就是：class 类型只能从一个 class 类型继承，而 multiclass 类型可以从多个 class 类型继承。&lt;/p&gt;

&lt;p&gt;class 类型通常比 multiclass 类型更有效率，因为 LLVM 可以更轻松地优化 class 类型。&lt;/p&gt;

&lt;p&gt;还是用 amd 的 td 文件来举例：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/IR/IntrinsicsAMDGPU.td&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;single-class&quot;&gt;single class&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DefaultAttrsIntrinsic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;llvm_i32_ty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntrNoMem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntrSpeculatable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;标识符 class 开头的就是单类。单类的名称是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;multi-class&quot;&gt;multi class&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;multiclass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic_xyz&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关键字是 multiclass，就是多类。&lt;/p&gt;

&lt;p&gt;这里多类的名称是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic_xyz&lt;/code&gt;，然后里面包含了多个单类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AMDGPUReadPreloadRegisterIntrinsic&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;btw，每个类都有一个名为 NAME（大写）的隐式模板参数，它绑定到从该类继承的 Def 或 Defm 的名称。如果该类由匿名记录继承，则名称未指定，但全局唯一。&lt;/p&gt;

&lt;p&gt;学了容易忘记，建议是用到的时候，可以看一下，基本上就知道了。&lt;/p&gt;

&lt;h1 id=&quot;区别&quot;&gt;区别&lt;/h1&gt;

&lt;p&gt;def 就是单纯的定义个单类的变量；
defm，这个多了一个 m，m 代表的就是 multiclass，就是定义的多类。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Feature&lt;/th&gt;
      &lt;th&gt;defm&lt;/th&gt;
      &lt;th&gt;def&lt;/th&gt;
      &lt;th&gt;defvar&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Type of entity&lt;/td&gt;
      &lt;td&gt;Multiclass&lt;/td&gt;
      &lt;td&gt;Class&lt;/td&gt;
      &lt;td&gt;Global variable&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Inheritance&lt;/td&gt;
      &lt;td&gt;Multiple inheritance&lt;/td&gt;
      &lt;td&gt;Single inheritance&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Can define&lt;/td&gt;
      &lt;td&gt;types&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实看了上面的 class 和 multiclass 的定义，就大概知道怎么用了。&lt;/p&gt;

&lt;p&gt;还有更多的 def* ，&amp;gt; https://llvm.org/docs/TableGen/ProgRef.html#id24&lt;/p&gt;

</description>
        <pubDate>Thu, 23 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/23/llvm-td-syntax-def-defm-defvar/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/23/llvm-td-syntax-def-defm-defvar/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        
      </item>
    
  </channel>
</rss>
