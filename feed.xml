<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>察说花园</title>
    <description>察说花园是一个关于我个人的学习记录过程，五花八门，关于互联网、TensorFlow、车载、安卓、音视频、存储、小程序和编译器的资讯和技术分享</description>
    <link>https://blog.chiphub.top/</link>
    <atom:link href="https://blog.chiphub.top/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 27 Oct 2025 14:29:13 +0000</pubDate>
    <lastBuildDate>Mon, 27 Oct 2025 14:29:13 +0000</lastBuildDate>
    <generator>Jekyll v3.10.0</generator>
    
      <item>
        <title>定位一个llvm19 升级带来的性能问题</title>
        <description>&lt;p&gt;问题： 在bitsandbytes里面，从llvm12升级到llvm19之后，部分性能下降。
matmul和double_quant，部分case性能下降6%~13%。
matmul的最后一个下降，13%&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/yyRQa6_aJ6KAt.png&quot;&gt;问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;思路是： 先复现这个问题，可以H列QA测试的结果保持一致。性能确实有回退。
先用内部工具，分析是哪一个kernel的占比耗时比较高。&lt;/p&gt;

&lt;p&gt;这个工具可以参考cuda profiler之类的工具，可以统计到每一个kernel执行的cycle值。&lt;/p&gt;

&lt;p&gt;同一个名称的 mangled 名称是一样的，mangled是带了参数的，所以不怕有不同参数的kernel 函数了。&lt;/p&gt;

&lt;p&gt;通过AI，直接生成一个python脚本，来分析这个json文件，大文件，记得用ijson，不是json。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/bYBsF6_Z9m52d.jpg&quot; alt=&quot;bYBsF6_Z9m52d&quot; /&gt;&lt;/p&gt;

&lt;p&gt;得到的数据，然后按照cycle的降序排序。
这个方法内部同事把这个定义为找hot kernel。
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/OVj49M_WfgZQn.jpg&quot; alt=&quot;OVj49M_WfgZQn&quot; /&gt;
可以看到这个回退的结果，里面其中一个kernel占比llvm12和19都是87%左右，挺大的，在看具体icycle值对比，也是回退和实际一致。&lt;/p&gt;

&lt;p&gt;问题找到了，可以下结论了。就是这个kernel 主要导致了性能回退的原因。&lt;/p&gt;

&lt;p&gt;那就开始深入分析kernel了，通过c++filt，可以看到这个kernel具体的名称，参数是什么？&lt;/p&gt;

&lt;p&gt;找到kernel name之后，在对应的测试集，或者是模型里面，找到对应的device函数名称。&lt;/p&gt;

&lt;p&gt;通过rg，或者grep 。找到这个函数在哪里。&lt;/p&gt;

&lt;p&gt;找到之后，
https://github.com/bitsandbytes-foundation/bitsandbytes/blob/main/csrc/kernels.cu:1766&lt;/p&gt;

&lt;p&gt;开源的工具，在1766行。&lt;/p&gt;

&lt;p&gt;是一个模板，看他实例化的地方，
https://github.com/bitsandbytes-foundation/bitsandbytes/blob/main/csrc/ops.cu： 446行的地方，有2个是实例化，但是参数对的上的之后一个。&lt;/p&gt;

&lt;p&gt;这个就好办了。&lt;/p&gt;

&lt;p&gt;先make的时候 verbose=1，打印出编译命令，然后修改这个cu文件，只保留这么一个实例化, 这样就搞了一个mini-case来复现问题。&lt;/p&gt;

&lt;p&gt;然后对比汇编。
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/fzgScS_UegfHX.jpg&quot; alt=&quot;fzgScS_UegfHX&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到llvm12的bb块多了很多，llvm19少了很多。&lt;/p&gt;

&lt;p&gt;可能的原因就是bb块多了之后，走到一个有endk的bb块，直接就跳出了。所以性能好。&lt;/p&gt;

&lt;p&gt;那就分析这个bb块是怎么来的，llvm19的bb块是怎么被优化没的。&lt;/p&gt;

&lt;p&gt;首先，通过-print-after-all, -filter-function-print， 找到只包含这个kernel的情况，获取到IR文件。&lt;/p&gt;

&lt;p&gt;用AI写一个python脚本，分析下这个只包含这个函数的bb块，变化情况。&lt;/p&gt;

&lt;p&gt;初步找到是inline一个pass导致的，
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/9aRmZ8_6CxjMy.jpg&quot; alt=&quot;9aRmZ8_6CxjMy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个就是不优化的，地方，说明是从其他子函数带过来的bb块。需要从子函数来分析。&lt;/p&gt;

&lt;p&gt;统计下print-after-inline后的bb情况变化， 可以看到llvm19是很高的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/KMg0Ih_hDlUVj.jpg&quot; alt=&quot;KMg0Ih_hDlUVj&quot; /&gt;&lt;/p&gt;

&lt;p&gt;方向对了。
那在看print-after-all， 就看这个bb块什么时候减少了。
&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/UdNu21_E20wQ0.jpg&quot; alt=&quot;UdNu21_E20wQ0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到前面都是73个bb块，后面就变成了17个， 就是这个simpfyCFG pass导致的，通过查看passBuilder pipeline这个pass。
找到对应的代码，主要上下的pass需要对应上，然后直接注释这个代码。&lt;/p&gt;

&lt;p&gt;先看看汇编有变化没？有了&lt;/p&gt;

&lt;p&gt;然后注释代码，看看性能怎么样？ 正常了。&lt;/p&gt;

&lt;p&gt;那就开始添加一个编译选项，专门控制这个地方，提供给bitsandbytes来使用。&lt;/p&gt;

&lt;p&gt;ok，梳理代码，提交，合并到dev，等待验证结果。&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Oct 2025 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2025/10/27/llvm19-trouble-shoting/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2025/10/27/llvm19-trouble-shoting/</guid>
        
        <category>llvm</category>
        
        <category>性能</category>
        
        
      </item>
    
      <item>
        <title>是 web3 游戏管理员骗局，还是 游戏项目？</title>
        <description>&lt;p&gt;TL;DR
推特上有人邀请我做游戏社区管理员 → 给了激活码让我下载一款所谓的游戏 → Windows / macOS 都无法运行 → 网站和白皮书看似正规，但账号粉丝大多是机器人 → 运行后发现有加密脚本在本地生成文件 → 怀疑是骗局或恶意软件。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;事情是这样的，前几天，我在推特上收到了一个私信，对方问我有没有兴趣做游戏社区的管理员。起初我并没有兴趣，就拒绝了。但后来他又说可以“先试试”，随后让我和一个自称是 HR 的人联系，并给了我一个 类似激活码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/gu3ZFu.jpg&quot; alt=&quot;invitedMe.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据他的指引，我用这个激活码在他们的网站上下载了一款所谓的游戏客户端。我分别在 Windows 和 macOS 上都试过，这个游戏都无法正常运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/yMZ8Gs.jpg&quot; alt=&quot;activateCode.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;奇怪的是：&lt;/p&gt;

&lt;p&gt;他们的网站和白皮书 做得很完整、很精致，看上去不像是随便拼凑的骗局页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/QiWzPo.jpg&quot; alt=&quot;website.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给我发私信的那个人，Discord 账号是 2018 年注册的，不是那种刚建的小号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/kcHLnN.jpg&quot; alt=&quot;discord.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是，我发现他们的推特账号有大量的 机器人粉丝，明显是批量注册刷出来的。给我发私信的人账号情况也类似。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/OKKFru.jpg&quot; alt=&quot;twitter.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我继续研究了一下。运行这个软件后，我发现它会执行一些 加密脚本，最后在本地生成文件。我不确定这是不是病毒或恶意软件，但至少看起来有风险。脚本都是混淆加密的～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/QiWzPo.jpg&quot; alt=&quot;script.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这让我很困惑：&lt;/p&gt;

&lt;p&gt;我是不是遇到了一个 包装得很像真的骗局？&lt;/p&gt;

&lt;p&gt;如果真是骗子，为什么要花这么多精力做一个看起来很完善的网站、白皮书和社区？&lt;/p&gt;

&lt;p&gt;还是说，他们的真正目的就是通过这个客户端来投放恶意程序？&lt;/p&gt;

&lt;p&gt;如果有人有沙盒环境，可以尝试运行一下这个客户端，看看会不会触发一些可疑的行为。&lt;/p&gt;

&lt;p&gt;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/virus.zip&lt;/p&gt;

&lt;p&gt;我也想听听大家的看法：这到底是一次web3 game尝试失败，还是一个伪装成游戏项目的骗局？&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Aug 2025 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2025/08/24/adventureverse-web3-game/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2025/08/24/adventureverse-web3-game/</guid>
        
        <category>adventureverse</category>
        
        <category>web3</category>
        
        
      </item>
    
      <item>
        <title>树莓派 4B 搭建 OpenWrt 热点 设置</title>
        <description>&lt;p&gt;这一篇文章是关于树莓派 4B 搭建 OpenWrt 热点的设置，主要是为了在树莓派上搭建一个热点，方便在没有网线的情况下连接到互联网。&lt;/p&gt;

&lt;p&gt;也是为了自己后面再来看的时候，可以设置点，如何设置。&lt;/p&gt;

&lt;h1 id=&quot;准备工作&quot;&gt;准备工作&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;硬件准备
首先是买一个免驱动的wifi网卡，拼多多不到20块钱一个。
树莓派4B，内存卡-8G&lt;/li&gt;
  &lt;li&gt;刷机
开始下载固件，这里由于树莓派的网卡是BCM的，就下载这个对应的版本就可以
下载suningGG的固件，我第一次没有解压刷机成功，第二次解压了刷机也是ok的
下载树莓派的刷包软件&lt;/li&gt;
  &lt;li&gt;刷完之后，启动
连接wifi Openwrt
登录192.168.1.1 不用输入密码&lt;/li&gt;
  &lt;li&gt;配置作为一个客户端，类似ap接入点
LAN口是转发出来的，最后的成品
WWAN口是扫描添加一个网口的&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;主要教程-step-by-step&quot;&gt;主要教程 step by step&lt;/h2&gt;
&lt;p&gt;主要参考的教程是这个：&lt;/p&gt;

&lt;p&gt;https://v2fy.com/p/2021-02-06-pi3-1612603909000/&lt;/p&gt;

&lt;p&gt;不知道后面还可以访问？
下面是这个教程的关键步骤。&lt;/p&gt;

&lt;p&gt;找刷机镜像
找到一个仓库 https://github.com/SuLingGG/OpenWrt-Rpi ，里面有树莓派全系设备的OpenWrt刷机镜像&lt;/p&gt;

&lt;p&gt;将镜像刷入SD卡
刷镜像软件下载地址: https://frp.v2fy.com/balenaEtcher/&lt;/p&gt;

&lt;p&gt;将SD卡插入树莓派，给树莓派通电开机
树莓派开机后20秒左右，使用电脑查看周围的Wifi，将会看到一个名为OpenWrt的Wifi网络，电脑可以直接加入OpenWrt网络（无需密码）&lt;/p&gt;

&lt;p&gt;登录树莓派路由器后台
打开浏览器，输入 http://192.168.1.1 进入路由器后台&lt;/p&gt;

&lt;p&gt;输入默认用户名，root 和 password&lt;/p&gt;

&lt;p&gt;配置Wan口
路由器也分入口和出口， 入口为Wan 口， 出口为Lan口， 上一步我们已经通过Wifi接入后台，说明Lank口已经没问题了， 而Wan口需要我们自己配置。&lt;/p&gt;

&lt;p&gt;如果我们将网线插入树莓派，则是和传统路由类似， 使用有线式Wan口。&lt;/p&gt;

&lt;p&gt;而我这次来个不一样的，将闲置的USB免驱无线网卡插入树莓派，做一个无线式Wan口。&lt;/p&gt;

&lt;h1 id=&quot;下次修改接入点-wifi-热点&quot;&gt;下次修改接入点 wifi 热点&lt;/h1&gt;

&lt;p&gt;刷机好了 ，设置好自己的
先扫描 wifi，添加到这个口
&lt;img src=&quot;../../../../img/2025/openwrt_1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后关联起来即可
&lt;img src=&quot;../../../../img/2025/openwrt_2.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;read-more&quot;&gt;read more&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;额外外接的网卡作为wan口，驱动成功后，在后台WAN口外接网卡可以直接扫描周围wifi，输入密码，接入互联网
https://v2fy.com/p/2021-07-04-openwrt-4b-1625383754000/comment-page-1/#comment-80842&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个教程全面：
把树莓派作为主路由、旁路由、AP热点-客户端
https://blog.csdn.net/qq_42523645/article/details/133755333&lt;/p&gt;

&lt;p&gt;可以借鉴下面这个教程里面的配图， 接入点ap的设置
https://zhuanlan.zhihu.com/p/451788328&lt;/p&gt;

&lt;p&gt;树莓派3b搭建openwrt科学上网， 用的sulingGG固件
https://tanweime.com/2023/05/03/%E6%A0%91%E8%8E%93%E6%B4%BE3b%E6%90%AD%E5%BB%BAopenwrt%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/&lt;/p&gt;
</description>
        <pubDate>Fri, 04 Apr 2025 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2025/04/04/Raspberry-pi-openwrt-ap-setup/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2025/04/04/Raspberry-pi-openwrt-ap-setup/</guid>
        
        <category>raspberry pi</category>
        
        <category>openwrt</category>
        
        
      </item>
    
      <item>
        <title>Foundry 工具初步探讨 - Forge</title>
        <description>&lt;h1 id=&quot;whats--foundry&quot;&gt;what’s  Foundry&lt;/h1&gt;

&lt;p&gt;Foundry 是用 Rust 编写的用于以太坊应用程序开发的快速、可移植和模块化工具包。&lt;/p&gt;

&lt;p&gt;来自官网的介绍&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Foundry consists of:

Forge: Build, test, fuzz, debug and deploy Solidity contracts, like Hardhat, Brownie, Ape.
Cast: A Swiss Army knife for interacting with EVM smart contracts, sending transactions and getting chain data.
Anvil: Fast local Ethereum development node, akin to Hardhat Network, Tenderly.
Chisel: Fast, utilitarian, and verbose Solidity REPL.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;反正就是对英语 dapp 测试基本上就用这个了，性能，功能，非常的灵活和强大。&lt;/p&gt;

&lt;h1 id=&quot;开始-1&quot;&gt;开始 1&lt;/h1&gt;

&lt;p&gt;安装下&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -L https://foundry.paradigm.xyz | bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;，提示网络错误，可以添加环境变量即可。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export https_proxy=http://127.0.0.1:7897 http_proxy=http://127.0.0.1:7897 all_proxy=socks5://127.0.0.1:7897
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行下 source， 就可以找到foundryup ，然后执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foundryup&lt;/code&gt;就可以安装了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2025/install_1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2025/install_done.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;forge-用法&quot;&gt;Forge 用法&lt;/h1&gt;

&lt;p&gt;Forge 是里面的一个工具之一。&lt;/p&gt;

&lt;p&gt;Forge：构建、测试、模糊、调试和部署 Solidity 合约，如 Hardhat、Brownie 和 Ape。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forge init&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2025/forge.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在当前目录可以看到一个文件,
里面的 foundry.toml 是 Forge 项目中的配置文件。在 foundry.toml 中使用 solc 配置编译器版本和优化次数：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[profile.default]
src = &apos;src&apos;
out = &apos;out&apos;
libs = [&apos;lib&apos;]

solc = &quot;0.8.x&quot; 
optimizer = true
optimizer_runs = 200 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后编译，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forge build&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2025/build.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行所有的测试。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forge test&lt;/code&gt;
&lt;img src=&quot;../../../../img/2025/test.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和 gtest 和 ctest 有点类似，支持过滤条件来执行 test cases.&lt;/p&gt;

&lt;h1 id=&quot;how-to-write-a-case&quot;&gt;how to write a case&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://book.getfoundry.sh/forge/writing-tests&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;for example .&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pragma solidity 0.8.10;

import {Test} from &quot;forge-std/Test.sol&quot;;

contract ContractBTest is Test {
    uint256 testNumber;

    function setUp() public {
        testNumber = 42;
    }

    function test_NumberIs42() public {
        assertEq(testNumber, 42);
    }

    /// forge-config: default.allow_internal_expect_revert = true
    function testRevert_Subtract43() public {
        vm.expectRevert();
        testNumber -= 43;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个 setup 是每个 case 之前都是需要执行的， 这个和其他测试框架类似&lt;/p&gt;

&lt;p&gt;test case 的名字必须用 test 开头，比如这里的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test_NumberIs42&lt;/code&gt;, 和 pytest 框架类似。&lt;/p&gt;

&lt;p&gt;这里主要顶部有一个 import ，这个就是将使用 Forge Std 的 Test 合约中的函数。该合约本身就是 DSTest 的超集。DSTest 提供基本的日志和断言功能。所以需要导入这个基础的测试集。&lt;/p&gt;

&lt;p&gt;assertEq 这个很好理解， 和其他断言超不多。&lt;/p&gt;

&lt;p&gt;第二个 test case，有点专业知识了理解。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testRevert_Subtract43&lt;/code&gt; 这个就是很少的一个名字，就是需要：测试用例期望合约操作会回滚。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;vm.expectRevert();
vm 是 Foundry 提供的特殊对象，用于模拟以太坊虚拟机（EVM）的行为.
expectRevert() 是一个断言，表示接下来的操作应该会导致回滚.
测试的结果：如果接下来的操作没有回滚，这个测试将会失败。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里为什么会失败？
由于在 setUp() 函数中 testNumber 被初始化为 42，减去 43 会导致下溢（underflow），这在 Solidity 0.8.x 版本中会触发回滚。&lt;/p&gt;

&lt;p&gt;典型的边界条件测试之一。&lt;/p&gt;

&lt;h1 id=&quot;read-more&quot;&gt;read more&lt;/h1&gt;

&lt;p&gt;https://github.com/foundry-rs/foundry
https://book.getfoundry.sh/&lt;/p&gt;
</description>
        <pubDate>Sun, 09 Feb 2025 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2025/02/09/Foundry-tools/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2025/02/09/Foundry-tools/</guid>
        
        <category>web3</category>
        
        <category>dapp</category>
        
        <category>Foundry</category>
        
        
      </item>
    
      <item>
        <title>智能合约 学习记录 1</title>
        <description>&lt;h1 id=&quot;初识-智能合约&quot;&gt;初识 智能合约&lt;/h1&gt;

&lt;p&gt;各位区块链世界的冒险者们，今天我们来聊聊一个既神奇又有点”笨笨”的东西——智能合约。想象一下，如果自动售货机突然学会了编程，还能自动执行各种复杂的任务，那会是什么样子？没错，这就是智能合约的魔力所在！&lt;/p&gt;

&lt;p&gt;首先，让我们来认识一下这个神奇的发明。智能合约是以太坊的一大创新，本质上就是运行在区块链上的程序。它就像是一个被严格管教的乖孩子，永远按照预设的规则行事，不会耍小聪明，也不会偷懒。&lt;/p&gt;

&lt;p&gt;为了确保所有的”孩子”都表现一致，以太坊还专门设立了一个超级严格的”老师”——以太坊虚拟机（EVM）。在 EVM 的监督下，所有的节点都必须得到一模一样的答案，就像是一群小学生在做一道数学题，每个人的答案都必须一致，否则就要被”罚站”。&lt;/p&gt;

&lt;p&gt;不过，这个”魔法自动售货机”也有它的局限性。比如，它不支持浮点运算，也不能生成真正的随机数。这就好比给程序员系上了手铐脚镣，让他们在写代码时束手束脚。但是，耍小聪明的开发者们总想找到办法绕过这些限制，就像是在玩一场智力游戏。&lt;/p&gt;

&lt;p&gt;说到开发，Solidity 是智能合约世界的”普通话”。如果你想在这个世界里畅通无阻，学好 Solidity 就像是学好普通话一样重要。&lt;/p&gt;

&lt;p&gt;有趣的是，智能合约部署后会获得一个地址，但这个地址就像是一个没有钥匙的保险箱，只能通过特定的方式打开。它没有私钥，只能通过调用公共函数来操作。这种设计确保了合约的安全性和透明度。&lt;/p&gt;

&lt;p&gt;智能合约还是个多面手，它不仅可以接收和发送以太币，还能存储数据。你可以把它想象成一个多功能的电子钱包，既能存钱，又能记账，简直是区块链世界的瑞士军刀！&lt;/p&gt;

&lt;p&gt;更厉害的是，合约还能调用其他合约，实现更复杂的功能。这就像是在玩积木游戏，通过组合不同的积木，我们可以搭建出令人惊叹的复杂结构。&lt;/p&gt;

&lt;p&gt;各位冒险者要注意了，使用智能合约也有一些需要特别小心的地方：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;合约的执行结果必须在所有节点上保持一致，这是保证其可信性的关键。就像是一群人在玩”传话游戏”，如果最后的结果不一致，那这个游戏就失去了意义。&lt;/li&gt;
  &lt;li&gt;编写合约时要时刻记住它的特殊限制，比如不支持浮点运算等。这就像是在玩一个特殊的拼图游戏，有些形状的拼图是不存在的，你得想办法用其他的拼图来代替。&lt;/li&gt;
  &lt;li&gt;合约不能主动执行，需要外部触发。这就像是一个沉睡的巨人，需要有人去推一把才能醒来。有时候，我们可能需要额外的线下服务来定期”叫醒”这个巨人。&lt;/li&gt;
  &lt;li&gt;合约间的嵌套调用虽然强大，但也增加了出错和被攻击的风险。这就像是在搭建一个复杂的多米诺骨牌，一不小心可能就会全盘崩溃。所以，编写时需要格外谨慎。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;智能合约就像是区块链世界的”自动售货机”，一旦部署好，就能按照预设的规则自动运行。&lt;/p&gt;

&lt;p&gt;这个”售货机”比普通的要复杂得多，既能存钱、付款，还能和其他”售货机”互动。不过，千万别把它想得太聪明，它还是需要我们这些人类来精心设计和小心使用的！&lt;/p&gt;

&lt;h1 id=&quot;如何写一个简单的智能合约&quot;&gt;如何写一个简单的智能合约&lt;/h1&gt;

&lt;p&gt;教程我是按照廖雪峰老师的教程，自己的操作了，写了一个vote投票的合约。&lt;/p&gt;

&lt;h2 id=&quot;1-首先申请测试网的ether&quot;&gt;1. 首先申请测试网的Ether&lt;/h2&gt;

&lt;p&gt;部署合约也是一个交易，需要一个外部账户，花费一定的Gas，就可以把合约部署到链上。&lt;/p&gt;

&lt;p&gt;测试环境不能用在真金白银， 就用测试环境的。&lt;/p&gt;

&lt;p&gt;如何申请？ 我是申请的这个网络的Ether。SepoliaETH&lt;/p&gt;

&lt;p&gt;以太坊有多个测试网，开发前请在Etherscan确认使用哪个活动的测试网。&lt;/p&gt;

&lt;p&gt;有些钱包不支持，比如我的okx的就不行，用的metamask。&lt;/p&gt;

&lt;p&gt;https://faucets.chain.link/sepolia&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/sepolia.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-部署合约&quot;&gt;2. 部署合约&lt;/h2&gt;
&lt;p&gt;访问Remix（注意：要部署合约，只能通过http访问，不能使用https），在左侧选择“File explorers”，在默认的Workspace的contracts目录下新建文件Vote.sol，然后贴入上一节我们编写的代码。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// SPDX-License-Identifier: GPL-3.0

pragma solidity =0.8.28;

contract Vote {

    event Voted(address indexed voter, uint8 proposal);

    mapping(address =&amp;gt; bool) public voted;

    uint256 public endTime;
    uint256 public startTime;

    uint256 public proposalA;
    uint256 public proposalB;
    uint256 public proposalC;

    constructor(uint256 _startTime, uint256 _endTime) {
        startTime = _startTime;
        endTime = _endTime;
    }

    function vote(uint8 _proposal) public {
        require(block.timestamp &amp;lt; endTime, &quot;Vote expired..&quot;);
        require(_proposal &amp;gt;= 1 &amp;amp;&amp;amp; _proposal &amp;lt;= 3, &quot;Invalid proposal.&quot;);
        require(!voted[msg.sender], &quot;Can not vote again.&quot;);
        voted[msg.sender] = true;
        if (_proposal == 1) {
            proposalA ++;
        }
        else if (_proposal == 2) {
            proposalB ++;
        }
        else if (_proposal == 3) {
            proposalC ++;
        }
        emit Voted(msg.sender, _proposal);
    }

    function votes() public view returns (uint256) {
        return proposalA + proposalB + proposalC;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于代码解释，看不懂的，可以直接丢给GPT分析下即可。&lt;/p&gt;

&lt;p&gt;合约只能有一个构造函数， 这里的函数，设置2个入参。&lt;/p&gt;

&lt;p&gt;ENVIRONMENT，这里选择钱包。
&lt;img src=&quot;../../../../img/2024/image-3.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;时间戳：设置为如图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-2.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击 transact。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-4.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;部署好之后，链上就可以看到了。&lt;/p&gt;

&lt;p&gt;交易tx的信息。从to里面可以看到一个contract的地址。和这个就是合约地址。
https://sepolia.etherscan.io/tx/0x98bd4157fefbd11bbb70cf808ddcd9fb7a031069f8581d080556883d7bd91c48&lt;/p&gt;

&lt;p&gt;合约：
https://sepolia.etherscan.io/address/0xd139e60592f4d7fd7177edd9f4d49a9f67608617&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-5.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以查看历史，钱包里面的活动页面，可以看到历史的。点开就可以看到了
&lt;img src=&quot;../../../../img/2024/image-6.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-调用和这个合约&quot;&gt;3. 调用和这个合约&lt;/h2&gt;

&lt;p&gt;调用之前，需要publish，发布的网址也是需要加一个二级域名的标识。&lt;/p&gt;

&lt;p&gt;我用的测试网络对应的是：&lt;a href=&quot;https://sepolia.etherscan.io/verifyContract&quot;&gt;verifyContract&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;按照提示，添加一些field即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-7.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;提交之后，这个合约的：&lt;a href=&quot;https://sepolia.etherscan.io/address/0xd139e60592f4d7fd7177edd9f4d49a9f67608617#code&quot;&gt;sepolia.etherscan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里contract有一个confirm的标识，绿色勾勾。
&lt;img src=&quot;../../../../img/2024/image-8.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;访问合约的只读函数时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;无需消耗Gas，也无需连接钱包&lt;/code&gt;，直接切换到“Read”面板，即可看到只读函数的返回值。&lt;/p&gt;

&lt;p&gt;最后一个voted，输入地址，query。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-9.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-写入合约&quot;&gt;4. 写入合约&lt;/h2&gt;

&lt;p&gt;当我们要写入合约时，就必须提交一个签名的交易，并消耗一定的Gas。我们在Etherscan的合约页选择“Write”，会出现一个“Connect to Web3”的链接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-11.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后查看交易链接：
&lt;a href=&quot;https://sepolia.etherscan.io/tx/0xac44e04612170a163b29cd42d8a1ff69ebdcfa964a5c5c8478f7d00ef2702b90&quot;&gt;sepolia.etherscan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后查看，这个地方的值就被修改为1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/image-10.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;read-more&quot;&gt;read more&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://liaoxuefeng.com/books/blockchain/ethereum/smart-contract/index.html&lt;/li&gt;
  &lt;li&gt;https://github.com/chaseSpace/learn_blockchain/blob/main/smart_contract_dev_guide.md&lt;/li&gt;
  &lt;li&gt;https://web3py.readthedocs.io/en/stable/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/09/11/smart-contract-guide/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/09/11/smart-contract-guide/</guid>
        
        <category>智能合约</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器最佳实践 - 后端</title>
        <description>&lt;h1 id=&quot;simt-是什么意思&quot;&gt;SIMT 是什么意思？&lt;/h1&gt;

&lt;p&gt;Single Instruction Multiple Threads” (SIMT) 单指令多线程。&lt;/p&gt;

&lt;p&gt;在纯 SIMD 中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;一条指令以完全相同的方式作用于所有数据&lt;/code&gt;。
在 SIMT 中，这一限制有所放松：可以激活或停用选定的线程，以便仅在活动线程上&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;处理指令和数据，而在非活动线程上本地数据保持不变。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因此，SIMT 可以适应分支，尽管效率不高。给定以 if (条件) 开头的 if-else 构造，当运行 if 子句中的语句时，condition==true 的线程将处于活动状态，而当运行 else 中的语句时，condition==false 的线程将处于活动状态条款。结果应该是正确的，但非活动线程在等待活动子句中的语句完成时不会执行任何有用的工作。SIMT 内的分支如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/simd_if.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Volta 之前的 NVIDIA GPU 中，整个 if 子句（即语句 A 和 B）必须由相关线程执行，然后整个 else 子句（语句 X 和 Y）必须由相关线程执行其余线程，则所有线程在继续执行之前都必须同步（语句 Z）。Volta 更灵活的 SIMT 模型允许在中间点（例如 A 和 X 之后）同步共享数据。&lt;/p&gt;

&lt;p&gt;这些不同的语句块在不同的线程里面，我们知道 GPU 都是并行运行的。那么这些线程都是执行的同一个命令，那结果怎么处理？&lt;/p&gt;

&lt;h1 id=&quot;warp&quot;&gt;warp&lt;/h1&gt;

&lt;p&gt;warp 是什么意思？&lt;/p&gt;

&lt;p&gt;指的是编织者的梭子穿过的一组垂直线-warp，为了后面更形象的理解吧。顺便说一下横着的是 weft。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../img/2024/warp-1.png&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在编程技术里面，是这个意思：The term warp originates from weaving, the first parallel-thread technology.&lt;/p&gt;

&lt;p&gt;在运行时，线程块被分为多个线程束以供 SIMT 执行。一个完整的 warp 由一组具有连续线程索引的 32 个线程组成。然后，warp 中的线程由一组 32 个 CUDA 核心一起处理。这类似于 CPU 上的向量化循环被分成固定大小的向量，然后由一组向量通道进行处理的方式。&lt;/p&gt;

&lt;p&gt;将线程捆绑为 32 个线程束的原因很简单，在 NVIDIA 的硬件中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CUDA 核心被分为固定的 32 个组&lt;/code&gt;。将大线程块分解成这种大小的块可以简化 SM 在其可用资源上调度整个线程块的任务。&lt;/p&gt;

&lt;p&gt;这个图，大家应该看到很多很多次了吧。&lt;/p&gt;

&lt;h1 id=&quot;read-more&quot;&gt;read more&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://cvw.cac.cornell.edu/gpu-architecture/gpu-characteristics/simt_warp&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/06/13/simt-warp/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/06/13/simt-warp/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>后端</category>
        
        
      </item>
    
      <item>
        <title>LLVM 快速入门 - 后端</title>
        <description>&lt;p&gt;如何快速的入门 llvm 后端？&lt;/p&gt;

&lt;h2 id=&quot;ide工具&quot;&gt;IDE工具&lt;/h2&gt;

&lt;p&gt;推荐一个工具clion：这个没有社区版的， 用付费的就可以， 其他的我不知道。&lt;/p&gt;

&lt;p&gt;有个trace功能，1个函数调用路径，然后右键查看源码可以跳转到源码里面去。&lt;/p&gt;

&lt;h2 id=&quot;操作系统&quot;&gt;操作系统&lt;/h2&gt;

&lt;p&gt;windoows， 不管是多大的项目，只要debug，几秒就可以调到断点的地方。&lt;/p&gt;

&lt;p&gt;我用的m1电脑，编译慢，调试而慢，应该是对于debug没有优化，windwos是 debug是优化过的。&lt;/p&gt;

&lt;p&gt;有懂的大佬可以留言，我学习学习。&lt;/p&gt;

&lt;h2 id=&quot;关于编译&quot;&gt;关于编译&lt;/h2&gt;

&lt;p&gt;装一个 c cache， 编译成动态库， 可以缓存编译的文件， 速度会快很多。&lt;/p&gt;

&lt;h2 id=&quot;关于寄存器的分配&quot;&gt;关于寄存器的分配&lt;/h2&gt;

&lt;p&gt;llvm太复杂了，寄存器分配那个地方非常难搞。&lt;/p&gt;

&lt;h2 id=&quot;学习后端pass&quot;&gt;学习后端pass&lt;/h2&gt;

&lt;p&gt;debug的速度决定了理解这个项目的速度，先了解这个pass是干什么的。&lt;/p&gt;

&lt;p&gt;首先，想如果是你你会怎么写，然后去代码里面找你脑中会怎么写的代码片段。&lt;/p&gt;

&lt;p&gt;对于GPU编译器， 看amd的编译器，在里面乱写，就改其中的1-2行，看看预期效果怎么回事，多弄几遍这个就会了。&lt;/p&gt;

&lt;h1 id=&quot;more&quot;&gt;more&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.jetbrains.com/clion/download/&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 01 Jun 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/06/01/llvm-learning-end/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/06/01/llvm-learning-end/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>后端</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器最佳实践 - 后端</title>
        <description>&lt;p&gt;学习内容来自网络课程，这个基本上是针对有点经验的 llvm 开发者，前面的就是过一遍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://books.google.com.tw/books?id=g_wqEAAAQBAJ&amp;amp;printsec=copyright&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用-passmanager-和-analysismanage&quot;&gt;使用 PassManager 和 AnalysisManage&lt;/h2&gt;

&lt;h2 id=&quot;处理-llvm-ir&quot;&gt;处理 LLVM IR&lt;/h2&gt;
&lt;h2 id=&quot;准备相关的工具&quot;&gt;准备相关的工具&lt;/h2&gt;
&lt;h2 id=&quot;学习-llvm-ir-表达式&quot;&gt;学习 LLVM IR 表达式&lt;/h2&gt;

</description>
        <pubDate>Sat, 01 Jun 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/06/01/llvm-learning-best_practice-2/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/06/01/llvm-learning-best_practice-2/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>后端</category>
        
        
      </item>
    
      <item>
        <title>LLVM 学习记录：编译器最佳实践 - 构建，Cmake 和 test</title>
        <description>&lt;p&gt;学习内容来自网络课程，这个基本上是针对有点经验的 llvm 开发者，前面的就是过一遍。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;https://books.google.com.tw/books?id=g_wqEAAAQBAJ&amp;amp;printsec=copyright&amp;amp;redir_esc=y#v=onepage&amp;amp;q&amp;amp;f=false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-构建技巧&quot;&gt;1. 构建技巧&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;用 ninja 构建&lt;/li&gt;
  &lt;li&gt;指定 lld 或者是 gold 的链接器&lt;/li&gt;
  &lt;li&gt;用特定的 cmake 参数来构建&lt;/li&gt;
  &lt;li&gt;构建不同的类型；debug，release，RelWithDebInfo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个我试了，RelWithDebInfo 又慢又大
 release，又快又小，如果不 debug 的话，用这个不错；
 debug 编译慢，空间占用的也非常的大。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;构建指定的目标 target， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD=&quot;X86;AMDGPU&quot; …&lt;/code&gt; ,有针对性的编译，速度会快很多；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建动态库： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DBUILD_SHARED_LIBS=ON&lt;/code&gt; 链接静态库通常比链接动态库花费更多的时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 gn 来编译，我没有成功；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM 的 GN 支持位于 llvm/utils/gn 文件夹中。&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-llvm-里面-cmake-用法&quot;&gt;2. llvm 里面 Cmake 用法&lt;/h2&gt;

&lt;p&gt;lib 是 LLVM 框架的基本构建块。&lt;/p&gt;

&lt;h3 id=&quot;cmake-添加新的库&quot;&gt;CMake 添加新的库&lt;/h3&gt;

&lt;p&gt;不要用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_library&lt;/code&gt;，要用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_component_library&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# In an in-tree CMakeLists.txt file…
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyLLVMPass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SHARED&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MyPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LLVM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;library&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么不要用这个？主要就是慢，而且不好扩展和控制。&lt;/p&gt;

&lt;h3 id=&quot;llvm-更喜欢使用全局-cmake-参数-即-build_shared_libs-来控制所有的组件库是静态构建还是动态构建使用内置指令很难做到这一点的&quot;&gt;LLVM 更喜欢使用全局 CMake 参数 (即 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILD_SHARED_LIBS&lt;/code&gt;) 来控制所有的组件库是静态构建还是动态构建。使用内置指令很难做到这一点的&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LLVM 更喜欢使用一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;全局的 CMake&lt;/code&gt; 参数来控制一些编译标志&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# In a CMakeLists.txt
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_component_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVMFancyOpt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FancyOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里，LLVMFancyOpt 是库名，FancyOpt.cpp 是源文件。&lt;/p&gt;

&lt;p&gt;注意下面 2 个用法是一样的：&lt;/p&gt;

&lt;p&gt;写到一个里面&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_component_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVMFancyOpt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FancyOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LINK_COMPONENTS&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Analysis&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScalarOpts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;分开写，先 link 组件：&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVM_LINK_COMPONENTS&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Analysis&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ScalarOpts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_llvm_component_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LLVMFancyOpt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FancyOpt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cmake-函数添加可执行文件和工具&quot;&gt;CMake 函数添加可执行文件和工具&lt;/h3&gt;

&lt;p&gt;可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_executable&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_tool&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_tool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myLittleTool&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MyLittleTool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一个全局的 CMake 变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_BUILD_TOOLS&lt;/code&gt;，用来启用/禁用 LLVM 工具。&lt;/p&gt;

&lt;h3 id=&quot;cmake-函数添加-pass-插件&quot;&gt;CMake 函数添加 Pass 插件&lt;/h3&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_llvm_pass_plugin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyPass&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HelloWorldPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LINK_COMPONENTS、LINK_LIBS 和 DEPENDS 参数也可以在这里使用，其用法和功能与 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_component_library&lt;/code&gt; 相同。&lt;/p&gt;

&lt;h2 id=&quot;3-lit-测试&quot;&gt;3. lit 测试&lt;/h2&gt;

&lt;p&gt;LIT 是一个测试基础设施，最初是为运行 LLVM 的回归测试而开发的。主要配合 Filecheck 来用。&lt;/p&gt;

&lt;p&gt;书里面，没有提到的，我这里补充一个，就是最好用 llvm-lit 工具，而不是 lit（python 的 lib）。&lt;/p&gt;

&lt;p&gt;如果还有就是可以自动更新 lit 测试的检查点；工具位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/util/update_xxxx.py&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;用法&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python update_xxx.py under_test_file.xx&lt;/code&gt;.&lt;/p&gt;

</description>
        <pubDate>Fri, 31 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/31/llvm-learning-best_practice-1/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/31/llvm-learning-best_practice-1/</guid>
        
        <category>llvm</category>
        
        <category>编译器</category>
        
        <category>测试</category>
        
        
      </item>
    
      <item>
        <title>一个程序员视角下，谈谈 Cursor 自动编码工具</title>
        <description>&lt;p&gt;想象一下，一个不懂编程的小白站在电脑前，面对着一堆凌乱的代码和复杂的设计需求，手足无措。突然，他看到了桌上那台小巧而神秘的设备——Cursor自动编码工具。它似乎能读懂他的每一个想法，并自动将其转换成可运行的程序。这不仅仅是一个虚构的故事，而是科技行业正在发生的真实转变。简述AI辅助编程工具在科技行业的重要性和发展背景。&lt;/p&gt;

&lt;p&gt;下面就来介绍下Cursor软件，包括其开发背景、核心功能及其对行业的影响。&lt;/p&gt;

&lt;h1 id=&quot;第一部分cursor的技术基础&quot;&gt;第一部分：Cursor的技术基础&lt;/h1&gt;

&lt;p&gt;在人工智能领域，Claude 3.5与GPT-4等模型代表了当前的前沿技术。这些模型采用先进的算法和大量数据集进行训练，能够处理复杂任务并提供高质量的输出。它们不仅在语言理解方面表现出色，而且在生成文本、图像识别以及其他模态中也展现出令人印象深刻的能力。这些先进模型的出现标志着人工智能研究进入了一个新的阶段，为各行各业带来了前所未有的机遇和挑战。&lt;/p&gt;

&lt;p&gt;如果你已经习惯了VS Code的高效开发，那么转到Cursor将是一次非常顺滑的体验。Cursor作为新一代的AI编程助手，在继承VS Code强大功能的基础上，更进一步地融入了AI智能，让编码过程变得更加高效和有趣。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/LsmruT.png&quot; alt=&quot;迁移从 vsvcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来看看有哪些功能？&lt;/p&gt;

&lt;h1 id=&quot;第二部分cursor-的核心功能&quot;&gt;第二部分：Cursor 的核心功能&lt;/h1&gt;

&lt;h2 id=&quot;1-代码自动生成与优化&quot;&gt;1. 代码自动生成与优化&lt;/h2&gt;

&lt;p&gt;尝试用 3 个语言来写 3 个程序。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;第一个 python，写一个快速排序。
直接写下最上面的一行注释，一个 tab 就完成。
```py
    &lt;h1 id=&quot;write-a-program-to-implement-quick-sort&quot;&gt;write a program to implement quick sort&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;def quick_sort(arr):
    if len(arr) &amp;lt;= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &amp;lt; pivot]
    right = [x for x in arr if x &amp;gt; pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)&lt;/p&gt;

&lt;p&gt;print(quick_sort([3, 6, 8, 10, 1, 2, 1]))&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2. 写一个 html 的页面。

```html
&amp;lt;!-- write a program to implement a tech style website, with a header, a footer, and a main content area --&amp;gt;

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;Tech Style Website&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background-color: #333;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        main {
            flex: 1;
            padding: 2rem;
        }
        footer {
            background-color: #333;
            color: white;
            padding: 1rem;
            text-align: center;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;header&amp;gt;
        &amp;lt;h1&amp;gt;Tech Style Website&amp;lt;/h1&amp;gt;
    &amp;lt;/header&amp;gt;
    &amp;lt;main&amp;gt;
        &amp;lt;h2&amp;gt;Welcome to our Tech Style Website&amp;lt;/h2&amp;gt;
        &amp;lt;p&amp;gt;This is the main content area of our website.&amp;lt;/p&amp;gt;
    &amp;lt;/main&amp;gt;
    &amp;lt;footer&amp;gt;
        &amp;lt;p&amp;gt;&amp;amp;copy; 2023 Tech Style Website. All rights reserved.&amp;lt;/p&amp;gt;
    &amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;效果图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/TgysfV.png&quot; alt=&quot;效果图&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写一个cuda的vectoradd  kernel 函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// write a program to implement vector addition&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;cuda_runtime.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vectorAdd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// allocate memory on the device&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// copy data to the device&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// launch the kernel&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vectorAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// copy the result back to the host&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyDeviceToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// free the memory&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d_c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;优化下代码
上面的 cuda 函数，对于返回的值，没有做校验,我只需要加一个“添加对结果检查”
几秒就完成了，速度非常快。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/G9Y3nH.png&quot; alt=&quot;优化&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有其他未开发的功能，对于一个新人来说，要完成一个产品从 0～1，是完全可以实现的。&lt;/p&gt;

&lt;h1 id=&quot;第三部分cursor的应用案例&quot;&gt;第三部分：Cursor的应用案例&lt;/h1&gt;

&lt;p&gt;Cursor作为一款强大的AI编码工具，正在深刻地改变着开发者们的编程方式。&lt;/p&gt;

&lt;p&gt;许多企业和个人开发者已经开始将Cursor应用于实际项目中，并取得了显著成效。例如，某大型互联网公司利用Cursor的代码生成功能，大幅提升了后端服务的开发效率，缩短了产品上线周期。而一位独立开发者则通过Cursor的智能补全功能，快速构建了一个个人博客系统。这些成功案例表明，Cursor不仅能满足企业级开发的需求，也能为个人开发者提供便利。&lt;/p&gt;

&lt;p&gt;AI编码工具的应用前景远不止于软件开发。在金融行业，Cursor可以用于构建复杂的量化交易模型；在生物医药领域，它能加速新药研发过程；在人工智能领域，Cursor可以辅助科学家进行模型训练和调参。随着AI技术的不断发展，AI编码工具将在越来越多的行业发挥重要作用。&lt;/p&gt;

&lt;p&gt;Cursor在某些特定领域展现出了独特的创新应用。例如，在游戏开发领域，Cursor可以自动生成游戏关卡、角色和物品，大大降低了游戏开发的门槛。在数据科学领域，Cursor可以帮助数据科学家快速构建数据分析管道，并生成可解释的模型。这些创新应用表明，Cursor不仅是一个代码编辑器，更是一个能激发开发者创造力的工具。
Cursor的出现，标志着编程方式正在发生一场革命。通过自动化代码生成、智能代码补全等功能，Cursor极大地提高了开发效率，降低了开发门槛。随着AI技术的不断进步，我们可以期待Cursor在未来能为我们带来更多的惊喜。&lt;/p&gt;

&lt;h1 id=&quot;第四部分cursor的未来展望&quot;&gt;第四部分：Cursor的未来展望&lt;/h1&gt;

&lt;p&gt;Cursor作为一款AI编程助手，在快速发展的AI编程工具市场中占据了一席之地。其精准的代码补全、高效的代码生成以及与自然语言的顺畅交互，使其在众多竞争对手中脱颖而出。然而，市场竞争日益激烈，来自GitHub Copilot、Tabnine等同类产品的挑战不容忽视。未来，Cursor需要在保持技术领先优势的同时，不断拓展应用场景，以巩固其市场地位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/6hd3OO.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Anysphere作为Cursor的母公司，与OpenAI等AI领域的领军企业保持着密切的合作关系。这种合作一方面可以加速Cursor的技术迭代，另一方面也能为Anysphere带来更多的资源和技术支持。未来，这种合作关系将进一步深化，推动AI编程工具的发展。&lt;/p&gt;

&lt;h1 id=&quot;结语&quot;&gt;结语&lt;/h1&gt;

&lt;p&gt;Cursor AI的出现，标志着编程工具迈入了智能化的新时代。通过将强大的AI能力融入到编程过程中，Cursor不仅提高了开发效率，而且降低了编程的门槛，为科技行业带来了深远的影响。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提升开发效率：  Cursor能够自动生成代码、智能补全、快速修复错误，大大缩短了开发周期，提高了开发效率。&lt;/li&gt;
  &lt;li&gt;降低编程门槛：  通过自然语言交互和智能提示，Cursor使得编程变得更加直观易懂，降低了编程学习的难度，吸引了更多的人加入到编程的行列。&lt;/li&gt;
  &lt;li&gt;促进创新：  Cursor为开发者提供了更多的可能性，激发了他们的创造力，促进了创新应用的诞生。&lt;/li&gt;
  &lt;li&gt;推动行业发展：  AI编程工具的普及，将加速软件开发行业的转型升级，推动整个科技产业的发展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chasays/mdPicGo/master/uPic/tEzQ83.png&quot; alt=&quot;&quot; /&gt;
上面这个是 github copilot 的介绍语。&lt;/p&gt;

&lt;p&gt;随着AI技术的不断成熟，AI编程工具将会越来越普及。我们鼓励更多的科技从业者拥抱这些新工具，将它们融入到日常的开发工作中。通过共同努力，我们可以共同推动编程生产力的提升，加速科技创新的步伐。&lt;/p&gt;

&lt;p&gt;虽然Cursor AI已经展现出了强大的能力，但它仍处于发展的初级阶段。未来，随着AI技术的不断进步，我们可以期待Cursor在以下几个方面取得更大的突破：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;更深入的代码理解：  能够理解更复杂的代码逻辑，实现更高级的代码重构和优化。&lt;/li&gt;
  &lt;li&gt;更广泛的应用场景：  除了传统的软件开发，还将在更多领域发挥重要作用，如数据科学、机器学习等。&lt;/li&gt;
  &lt;li&gt;更强的安全性：  能够更好地保障代码的安全性，防止恶意代码的生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cursor AI的出现，预示着编程行业正在经历一场深刻的变革。通过拥抱AI，我们可以创造一个更加智能、高效的编程未来。让我们共同期待，AI编程工具能够为我们带来更多的惊喜。&lt;/p&gt;

</description>
        <pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate>
        <link>https://blog.chiphub.top/2024/05/28/talk-cursor-in-programmer-view/</link>
        <guid isPermaLink="true">https://blog.chiphub.top/2024/05/28/talk-cursor-in-programmer-view/</guid>
        
        <category>编辑器</category>
        
        <category>cursor</category>
        
        
      </item>
    
  </channel>
</rss>
